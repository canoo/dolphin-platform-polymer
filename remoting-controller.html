<link rel="import" href="../polymer/polymer-element.html">

<dom-module id="remoting-controller">
    <template>
        <slot></slot>
    </template>
    <script>
        (function() {

            // Internal methods which are not added to the class
            // TODO: This methos are also in use in the AngularJS version ... they should be moved to the core!

            /**
             * Checks whether an object exists or not.
             *
             * @param {any} object The object which should be checked
             */
            const exists = function (object) {
                return typeof object !== 'undefined' && object !== null;
            };

            /**
             * Compares two arrays.
             *
             * @param {any[]} array1 Array
             * @param {any[]} array2 Array
             */
            const deepEqual = function (array1, array2) {
                if (array1 === array2 || (!exists(array1) && !exists(array2))) {
                    return true;
                }
                if (exists(array1) !== exists(array2)) {
                    return false;
                }
                const n = array1.length;
                if (array2.length !== n) {
                    return false;
                }
                for (let i = 0; i < n; i++) {
                    if (array1[i] !== array2[i]) {
                        return false;
                    }
                }
                return true;
            };

            /**
             * Injects one array into the other at a given index.
             *
             * @param {any[]} baseArray The array to insert the other array to
             * @param {number} startIndex The index at which the array should be added
             * @param {any[]} insertArray The array which should be added
             */
            const injectArray = function (baseArray, startIndex, insertArray) {
                baseArray.splice.apply(baseArray, [startIndex, 0].concat(insertArray));
            };

            const beanToPath = new Map();

            const calculateBeanPath = function(path, bean) {
                if (!exists(bean)) {
                    return;
                }
                beanToPath.set(bean, path);
                if (Array.isArray(bean)) {
                    for (let i = 0; i < bean.length; i++) {
                        const currentName = path + '.' + i;
                        const value = bean[i];
                        calculateBeanPath(currentName, value);
                    }
                } else if (typeof bean === 'object') {
                    const keys = Object.keys(bean);
                    for (let i = 0; i < keys.length; i++) {
                        const currentName = path + '.' + keys[i];
                        const key = keys[i];
                        const value = bean[key];
                        calculateBeanPath(currentName, value);
                    }
                }
                
            }

            const calulateBeanPathForModel = function(model) {
                beanToPath.clear();
                calculateBeanPath('model', model);
            }

            // Internal field which are not added to the class

            /** Instance of the Dolphin Controller. */
            let controller = null;

            /** State of the initialization. */
            let initialized = false;

            /** Interal version of the Dolphin Platform client context. */
            let internalClientContext = null;

            /**
             * The `remoting-controller` element creates a connection between Polymer and the Dolphin Platform.
             *
             * ~~~html
             * <remoting-controller name="TodoController" model="{{todos}}"></remoting-controller>
             * ~~~
             *
             * The `remoting-controller` sends events after creation and destruction of the Dolphin Platform Controller.
             * ~~~html
             * <remoting-controller name="TodoController" model="{{todos}}" on-postconstruct="myMethod" on-postdestroyed="myOtherMethod"></remoting-controller>
             * ~~~
             *
             * The `remoting-controller` sends events after been added to or removed from the document.
             * ~~~html
             * <remoting-controller name="TodoController" model="{{todos}}" on-connect="myMethod" on-disconnect="myOtherMethod"></remoting-controller>
             * ~~~
             *
             * The `remoting-controller` can be used as not managed version. For that case you have to invoke the create() and destroy() methods on your own.
             * ~~~html
             * <remoting-controller name="TodoController" model="{{todos}}" not-managed></remoting-controller>
             * ~~~
             *
             * @customElement
             * @polymer
             */
            class RemotingController extends Polymer.Element {

                constructor() {
                    super();
                    this._onAdded = this._onAdded.bind(this);
                    this._onRemoved = this._onRemoved.bind(this);
                    this._onBeanUpdate = this._onBeanUpdate.bind(this);
                    this._onArrayUpdate = this._onArrayUpdate.bind(this);
                    this._handleControllerCreated = this._handleControllerCreated.bind(this);
                    this._handleControllerDestroyed = this._handleControllerDestroyed.bind(this);
                }

                static get is() {
                    return "remoting-controller"
                }

                static get properties() {
                    return {
                        /** The name of the controller which is used for the Dolphin Platform Controller. */
                        name: String,

                        /** The model of the controller which is conntected to the Dolphin Platform. It will be updated by the Dolphin Platform. */
                        model: {
                            type: Object,
                            notify: true
                        },

                        /** This property allows to disable the self-management of the component. If it is set (`true`) the component must be initialized and destroyed by hand with `create()` and `destroy()`! */
                        notManaged: {
                            type: Boolean,
                            value: false
                        }
                    }
                }

                /**
                 * Provides an extended implementation of the standard Custom Elements `connectedCallback`.
                 *
                 * This method will be called if this element is added to a document.
                 *
                 * If this is a managed component, this method will create the internal Platform Controller if there is already a Dolphin Platform client context.
                 * Hint: For a managed component, the `window.clientContext` MUST be created before the `remoting-controller` is added to a document.
                 */
                connectedCallback() {
                    RemotingController.LOGGER.debug(this.name, 'Conntected to document.');
                    super.connectedCallback();

                    const managed = !this.get('notManaged');
                    if (managed) {
                        this._create();
                    }

                    const event = new CustomEvent('connected', {detail: this, bubbles: true, composed: true});
                    this.dispatchEvent(event);

                }

                /**
                 * Provides an implementation which is called when the element is removed from a document.
                 *
                 * If the Remoting Controller is managed, this method will also destroy the internal Platform Controller.
                 */
                disconnectedCallback() {
                    RemotingController.LOGGER.debug(this.name, 'Disconnected from document.');
                    super.disconnectedCallback();

                    const managed = !this.get('notManaged');
                    if (managed) {
                        this._destroy();
                    }

                    const event = new CustomEvent('disconnected', {detail: this, bubbles: true, composed: true});
                    this.dispatchEvent(event);
                }

                /**
                 * Creates the internal Platform Controller for a not managed component.
                 *
                 * @returns {Promise} Promise which will be resolved after the creation of the internal Platform Controller
                 */
                create() {
                    const notManaged = this.get('notManaged');
                    if (notManaged) {
                        const self = this;
                        return new Promise(function(resolve, reject) {
                            self.addEventListener('postconstruct', function() {
                                resolve();
                            });
                            self._create();
                        });
                    } else {
                        RemotingController.LOGGER.error(this.name, 'Cannot invoke create() method for a managed Controller');
                        throw new Error('Cannot invoke create() method for a managed Controller');
                    }
                }

                /**
                 * Destroys the internal Platform Controller for a not managed component.
                 * 
                 * @returns {Promise} Promise which will be resolved after the destruction of the internal Platform Controller
                 */
                destroy() {
                    const notManaged = this.get('notManaged');
                    if (notManaged) {
                        const self = this;
                        return new Promise(function(resolve, reject) {
                            self.addEventListener('postdestroyed', function() {
                                resolve();
                            });
                            self._destroy();
                        });
                    } else {
                        RemotingController.LOGGER.error(this.name, 'Cannot invoke destroy() method for a managed Controller');
                        throw new Error('Cannot invoke destroy() method for a managed Controller');
                    }
                }

                /**
                 * Invokes an action on the Dolphin Platform Controller with given name and parameters.
                 *
                 * @param {string} name Name of the action. MUST match an action name on the server side
                 * @param {any[]} params Array of parameters for the action
                 *
                 * @returns {Promise} Promise which will be resolved the action was invoked on the server, or will be rejected on error.
                 */
                invoke(name, params) {
                    RemotingController.LOGGER.debug(this.name, 'Invoke action called with', name, params);
                    if (exists(controller)) {
                        return controller.invoke(name, params)
                    } else {
                        RemotingController.LOGGER.error('No Dolphin Controller found. Cannot invoke action:', name, 'Parameters:', params);
                    }
                }

                /**
                 * Creates the internal Platform Controller.
                 */
                _create() {
                    internalClientContext = window.clientContext;

                    if (internalClientContext) {
                        this._createController();
                    } else {
                        RemotingController.LOGGER.error('No Dolphin Platform client context found! Cannot create Dolphin Controller.');
                        throw new Error('No Dolphin Platform client context found! Cannot create Dolphin Controller.');
                    }
                }

                /**
                 * Destroys the internal Platform Controller.
                 */
                _destroy() {
                    if (exists(controller)) {
                        controller.destroy();
                    }
                }

                /**
                 * Handles model changes received from the Polymer observers.
                 *
                 * @param {any} changes The changes made to the model
                 */
                 _modelChanged(changes) {
                    
                    if (changes) {
                        const arrayChange = changes.path.indexOf('.splices') >= 0;
                        RemotingController.LOGGER.debug(this.name, 'Model changed', 'Changes:', changes, 'Is Array change:', arrayChange);

                        const { value, base, path } = changes;
                        const elements = Polymer.Path.split(path);

                        if (arrayChange) {
                            if (value.indexSplices) {
                                for (let i = 0; i < value.indexSplices.length; i++) {
                                    const position = elements.length-2;
                                    const splice = value.indexSplices[i];
                                    const startIndex = splice.index;
                                    const removedItems = splice.removed;
                                    const addedCount = splice.addedCount;
                                    const propertyName = elements[position];

                                    const currentPath = Polymer.Path.normalize([...elements].splice(0, position));
                                    const bean = this.get(currentPath);
                                    RemotingController.LOGGER.trace(this.name, 'Bean:', bean, 'Removed:', removedItems);
                                    internalClientContext.beanManager.notifyArrayChange(bean, propertyName, startIndex, addedCount, removedItems);
                                }
                            }
                            
                        } else {
                            if (elements.length > 1) {
                                // subproperty changed
                                const position = elements.length-1;
                                const propertyName = elements[position];
                                const currentPath = Polymer.Path.normalize([...elements].splice(0, position));
                                const bean = this.get(currentPath);
                                
                                RemotingController.LOGGER.trace(this.name, 'Bean:', bean, 'Value:', value);
                                if (bean) {
                                    internalClientContext.beanManager.notifyBeanChange(bean, propertyName, value);
                                }
                            } else {
                                // root property changed
                                const propertyName = elements[0];
                                const currentPath = Polymer.Path.normalize(elements);
                                const bean = this.get(currentPath);
                                
                                RemotingController.LOGGER.trace(this.name, 'Bean:', bean, 'Value:', value);
                                if (bean) {
                                    internalClientContext.beanManager.notifyBeanChange(bean, propertyName, value);
                                }
                            }
                        }
                    }

                }

                _onAdded(bean) {
                    RemotingController.LOGGER.trace(this.name, 'Added', bean);
                }

                _onRemoved(bean) {
                    RemotingController.LOGGER.trace(this.name, 'Removed', bean);
                }

                /**
                 * Handles bean upadates from the Dolphin Platform.
                 *
                 * @param {any} bean The bean which was changed
                 * @param {string} propertyName The name of the property which was changed
                 * @param {any} newValue The new value of the property
                 * @param {any} oldValue the old value of the property
                 */
                _onBeanUpdate(bean, propertyName, newValue, oldValue) {
                    RemotingController.LOGGER.trace(this.name, 'Updating bean', bean, 'property name:', propertyName, 'new value:', newValue, 'old value:', oldValue);

                    if (oldValue === newValue) {
                        RemotingController.LOGGER.trace(this.name, 'Received bean update for property ', propertyName, ' without any change');
                        return;
                    }

                    if (initialized) {
                        const beanPath = beanToPath.get(bean);

                        if (exists(beanPath)) {
                            const currentPath = Polymer.Path.normalize([beanPath, propertyName]);

                            if (Array.isArray(newValue) && newValue.length === 0) {
                                this.set(currentPath, newValue);
                            }

                            this.notifyPath(currentPath);
                        }
                        
                    }
                    bean[propertyName] = newValue;
                    
                }

                /**
                 * Handles array upadates from the Dolphin Platform (e.g. `ObservableList`).
                 */
                _onArrayUpdate(bean, propertyName, index, count, newElements) {
                    RemotingController.LOGGER.trace(this.name, 'Updating array bean', bean, 'property name:', propertyName, 'index:', index, 'count:', count, 'newElements:', newElements);
                    
                    const array = bean[propertyName];
                    const oldElements = [bean[propertyName][index]];

                    if (deepEqual(newElements, oldElements)) {
                        RemotingController.LOGGER.trace(this.name, 'Will not add equal elements');
                        return;
                    }

                    if (initialized) {
                        const beanPath = beanToPath.get(bean);

                        if (exists(beanPath)) {
                            const currentPath = Polymer.Path.normalize([beanPath, propertyName]);
                            const currentValue = this.get(currentPath);

                            if (currentValue) {
                                const result = this.splice(currentPath, index, count, ...newElements);

                                if (result) {
                                    calulateBeanPathForModel(this.model);
                                }
                            }
                        } else {
                            RemotingController.LOGGER.error(this.name, 'Bean not found in model!', bean, propertyName);
                        }
  
                    } else {
                        injectArray(array, index, newElements);
                    }

                }

                /**
                 * Handles the destruction of a Dolphin Controller.
                 *
                 * This method resets the model.
                 */
                _handleControllerDestroyed() {
                    RemotingController.LOGGER.debug(this.name, 'Dolphin Platform controller destroyed');

                    this.set('model', {});
                    controller = null;
                    initialized = false;

                    const event = new CustomEvent('postdestroyed', {detail: this, bubbles: true, composed: true});
                    this.dispatchEvent(event);
                }

                /**
                 * Handles the creation of a Dolphin Controller.
                 *
                 * @param {object} controllerProxy The `ControllerProxy` from the Dolphin Platform.
                 */
                _handleControllerCreated(controllerProxy) {
                    RemotingController.LOGGER.debug(this.name, 'Dolphin Platform controller created', controllerProxy.getId(), controllerProxy);
                    controllerProxy.onDestroyed(this._handleControllerDestroyed);
                    controller = controllerProxy;
                    this.set('model', controllerProxy.getModel());
                    calulateBeanPathForModel(controllerProxy.getModel());
                    initialized = true;

                    const event = new CustomEvent('postconstruct', {detail: this, bubbles: true, composed: true});
                    this.dispatchEvent(event);
                }

                /**
                 * Creates a Dolphin controller and registers the listeners for bean updates.
                 */
                _createController() {
                    this._createMethodObserver('_modelChanged(model.*)', true);
                    RemotingController.LOGGER.info('Creating Dolphin Platform controller', this.name);

                    // Register callbacks for the Dolphin Platform bean manager
                    internalClientContext.beanManager.onAdded(this._onAdded);
                    internalClientContext.beanManager.onRemoved(this._onRemoved);
                    internalClientContext.beanManager.onBeanUpdate(this._onBeanUpdate);
                    internalClientContext.beanManager.onArrayUpdate(this._onArrayUpdate);


                    internalClientContext.createController(this.name).then(this._handleControllerCreated);
                }
            }

            if (!exists(window.dolphin)) {
                throw new Error('No Dolphin Platform found in "window" global. Please load Dolphin Platform first.');
            }

            /** Default logger for the Controller. */
            RemotingController.LOGGER = window.dolphin.LoggerFactory.getLogger('RemotingController');

            // Register the element
            customElements.define(RemotingController.is, RemotingController);

        })();

    </script>
</dom-module>