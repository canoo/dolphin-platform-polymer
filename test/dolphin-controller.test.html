<!-- ------------------------------------------------------------------------------------------ -->
<!-- IMPORTS.
<!-- ------------------------------------------------------------------------------------------ -->

<script src="../../webcomponentsjs/webcomponents-loader.js"></script>
<script src="../../web-component-tester/browser.js"></script>
<script src="../../dolphin-platform-js/dist/dolphin-platform.js"></script>
<link rel="import" href="../dolphin-controller.html">

<!-- ------------------------------------------------------------------------------------------ -->
<!-- FIXTURES.
<!-- ------------------------------------------------------------------------------------------ -->

<test-fixture id="EmptyController">
  <template>
    <dolphin-controller no-create no-destroy></dolphin-controller>
  </template>
</test-fixture>

<test-fixture id="SimpleController">
  <template>
    <dolphin-controller name="SimpleController"></dolphin-controller>
  </template>
</test-fixture>

<!-- ------------------------------------------------------------------------------------------ -->
<!-- FEATURES.
<!-- ------------------------------------------------------------------------------------------ -->

<script>
  // mocha.checkLeaks()

  function pretty(value, padding = 2) {
    return JSON.stringify(value, null, padding)
  }

  function pretty1(value) {
    const string = pretty(value, 1)
    return string.split("\n").map(it => it.trim()).join(" ")
  }

  function pretty0(value) {
    return pretty(value, 0)
  }

  function createClientContext(url = "http://localhost:8080/dolphin") {
    const factory = new dolphin.ClientContextFactory()
    const config = {}
    return factory.create(url, config)
  }

  function createClientContextMock() {
    const clientContext = {
      _model: null,
      beanManager: {
        onBeanUpdate: () => null,
        onArrayUpdate: () => null,
        notifyBeanChange: () => null,
        notifyArrayChange: () => null,
      },
      createController: (name) => {
        let onDestroyedCallback
        return Promise.resolve({
          model: clientContext._model,
          destroy: () => {
            if (onDestroyedCallback) {
              onDestroyedCallback()
            }
          },
          onDestroyed: (callback) => {
            onDestroyedCallback = callback
          }
        })
      }
    }
    return clientContext
  }

  suite("<dolphin-controller>", () => {

    //----------------------------------------------------------------------------------------------
    // SUITE.
    //----------------------------------------------------------------------------------------------

    suite.only("simple binding (of bean)", () => {
      // fixtures:
      let stringBean

      setup(() => {
        // setup:
        stringBean = { stringProp: "ONE" }
        window.clientContext = createClientContextMock()
        window.clientContext._model = stringBean
      })

      test("initial bean (from dolphin)", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // expect:
          expect(controller.model).to.eql(stringBean)
          expect(controller.model.stringProp).to.eql("ONE")
          // TODO(hastebrot): expect notify bean property changed?
          done()
        })
      })

      test("changed bean property (from dolphin)", done => {
        // given:
        const controller = fixture("SimpleController")
        const onModelChangedSpy = sinon.spy(controller, "_onModelChanged")

        flush(() => {
          // when:
          controller._onBeanPropertyChanged(stringBean, "stringProp", "TWO", "ONE")

          // then:
          expect(controller.model).to.eql(stringBean)
          expect(controller.model.stringProp).to.eql("TWO")
          done()
        })
      })

      test("changed bean property (from polymer)", done => {
        // given:
        const controller = fixture("SimpleController")
        const notifyBeanPropertyChangedSpy = sinon.spy(
          controller, "_notifyBeanPropertyChanged")

        flush(() => {
          // when:
          controller.set("model.stringProp", "TWO")

          // then:
          expect(controller.model).to.eql(stringBean)
          expect(controller.model.stringProp).to.eql("TWO")

          // and:
          // https://github.com/domenic/sinon-chai#assertions
          console.log("spy.args", pretty1(notifyBeanPropertyChangedSpy.args))
          expect(notifyBeanPropertyChangedSpy).to.have.been.calledWith(
            stringBean, "stringProp", "TWO")
          done()
        })
      })
    })

    //----------------------------------------------------------------------------------------------
    // SUITE.
    //----------------------------------------------------------------------------------------------

    suite.only("simple binding (of array)", () => {
      // fixtures:
      let arrayBean

      setup(() => {
        // setup:
        arrayBean = { arrayProp: [1, 2, 3] }
        window.clientContext = createClientContextMock()
        window.clientContext._model = arrayBean
      })

      test("initial bean (from dolphin)", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // expect:
          expect(controller.model).to.eql(arrayBean)
          expect(controller.model.arrayProp).to.eql([1, 2, 3])
          done()
        })
      })

      test("spliced bean property (from dolphin)", done => {
        // given:
        const controller = fixture("SimpleController")
        const onModelChangedSpy = sinon.spy(controller, "_onModelChanged")

        flush(() => {
          // when:
          controller._onBeanPropertySpliced(arrayBean, "arrayProp", 1, 0, [10, 11])

          // then:
          // expect(onModelChangedSpy).to.have.been.calledWith({
          //   path: "model.arrayProp.slices",
          //   value: { arrayProp: [1, 90, 91, 2, 3] },
          //   base: { arrayProp: [1, 90, 91, 2, 3] }
          // })

          expect(controller.model).to.eql({ arrayProp: [1, 10, 11, 2, 3] })
          done()
        })
      })

      test("spliced bean property (from polymer)", done => {
        // given:
        const controller = fixture("SimpleController")
        const onModelChangedSpy = sinon.spy(controller, "_onModelChanged")

        flush(() => {
          // when:
          controller.splice("model.arrayProp", 1, 0, ...[10, 11])
          // controller._onBeanPropertySpliced(arrayBean, "arrayProp", 1, 0, [10, 11])

          // then:
          // expect(onModelChangedSpy).to.have.been.calledWith({
          //   path: "model.arrayProp.slices"
          // })

          expect(controller.model).to.eql({ arrayProp: [1, 10, 11, 2, 3] })
          done()
        })
      })
    })

    //----------------------------------------------------------------------------------------------
    // SUITE.
    //----------------------------------------------------------------------------------------------

    suite.skip("bean registry", () => {
      let controller
      setup(() => {
        // given:
        controller = fixture("EmptyController")
      })

      const fooBean = { stringProp: "foo" }
      const barBean = { stringProp: "bar" }

      test("initialize", () => {
        expect(controller._beanRegistry).to.eql(new Map())
      })

      test("query property paths", () => {
        controller._registerPropertyPath(fooBean, "model.selectedUser")

        expect(controller._queryPropertyPaths(fooBean)).to.eql(
          new Set(["model.selectedUser"]))
        expect(controller._queryPropertyPaths(barBean)).to.eql(
          new Set())
      })

      test("register property path", () => {
        controller._registerPropertyPath(fooBean, "model.selectedUser")
        controller._registerPropertyPath(barBean, "model.users.0")
        controller._registerPropertyPath(fooBean, "model.users.1")

        expect(controller._queryPropertyPaths(fooBean))
          .to.eql(new Set(["model.selectedUser", "model.users.1"]))
        expect(controller._queryPropertyPaths(barBean))
          .to.eql(new Set(["model.users.0"]))

        expect(controller._beanRegistry)
          .to.eql(new Map([
            [fooBean, new Set(["model.selectedUser", "model.users.1"])],
            [barBean, new Set(["model.users.0"])]
          ]))
      })

      test("unregister property path", () => {
        controller._registerPropertyPath(fooBean, "model.selectedUser")
        controller._registerPropertyPath(barBean, "model.users.0")
        controller._registerPropertyPath(fooBean, "model.users.1")

        controller._unregisterPropertyPath(fooBean, "model.selectedUser")
        controller._unregisterPropertyPath(fooBean, "model.users.1")

        expect(controller._queryPropertyPaths(fooBean))
          .to.eql(new Set())
        expect(controller._queryPropertyPaths(barBean))
          .to.eql(new Set(["model.users.0"]))

        expect(controller._beanRegistry)
          .to.eql(new Map([
            [barBean, new Set(["model.users.0"])]
          ]))
      })

      test("slice property path", () => {
        expect(controller._slicePropertyPath("model.users.1.firstName", 0, 1))
          .to.equal("model")
        expect(controller._slicePropertyPath("model.users.1.firstName", 1))
          .to.equal("users.1.firstName")
        expect(controller._slicePropertyPath("model.users.1.firstName", -1))
          .to.equal("firstName")
        expect(controller._slicePropertyPath("model.users.1.firstName", 0, -1))
          .to.equal("model.users.1")
        expect(controller._slicePropertyPath("model.users.1.firstName", 1, -1))
          .to.equal("users.1")

        expect(controller._slicePropertyPath("model.users.1.firstName", -2))
          .to.equal("1.firstName")
        expect(controller._slicePropertyPath("model.users.1.firstName", 0, -2))
          .to.equal("model.users")
      })
    })

    //----------------------------------------------------------------------------------------------
    // SUITE.
    //----------------------------------------------------------------------------------------------

    suite.skip("bean registry bindings", () => {
      setup(() => {
        // setup:
        window.clientContext = createClientContextMock()
        window.clientContext._model = {
          arrayBean: {
            arrayProp: [0, { id: 1 }, { id: 2 }, 3, 4, 5]
          }
        }
      })

      test("binder update array", done => {
        // TODO(hastebrot): isNil(bean) on _onModelChanged() makes problems.

        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          controller.splice("model.arrayBean.arrayProp", 2, 2, ...[10, 11, 12])
          controller.splice("model.arrayBean.arrayProp", 0, 10, ...[{ id: 13 }])
          // controller.set("model.arrayBean.arrayProp", [{ id: 14 }])
          done()
        })
      })
    })

    //----------------------------------------------------------------------------------------------
    // SUITE.
    //----------------------------------------------------------------------------------------------

    suite("with client context", () => {
      setup(() => {
        window.clientContext = createClientContextMock()
      })

      test("set the initial value", done => {
        // given:
        const bean = { stringProp: "VALUE_1" }
        window.clientContext.createController = (name) => {
          return Promise.resolve({ model: bean, destroy: () => { } })
        }

        // when:
        const controller = fixture("SimpleController")

        // then:
        flush(() => {
          expect(controller.model).to.equal(bean)
          expect(controller.model.stringProp).to.equal("VALUE_1")
          done()
        })
      })

      test("synchronize changes coming from Dolphin", done => {
        // given:
        const bean = { stringProp: "VALUE_1" }
        window.clientContext._model = bean

        // when:
        const controller = fixture("EmptyController")

        // then:
        flush(() => {
          controller._onBeanPropertyChanged(bean, "stringProp", "VALUE_2", "VALUE_1")
          // sinon.assert.calledWithExactly(element.beanChangeObserver, { path: 'model.theProperty', value: 'VALUE_2', base: bean });
          done()
        })
      })

      test("create controller", done => {
        // given:
        const controller = fixture("EmptyController")
        controller.name = "EmptyController"

        // when:
        controller.create()

        // then:
        flush(() => {
          expect(controller.status).to.equal("READY")
          done()
        })
      })

      test("destroy controller", done => {
        // given:
        const controller = fixture("EmptyController")
        controller.name = "EmptyController"
        controller.create()

        // when:
        flush(() => {
          controller.destroy()

          // then:
          expect(controller.status).to.equal("NOT-READY")
          done()
        })
      })

      test("auto create controller", done => {
        // when:
        const controller = fixture("SimpleController")

        // then:
        flush(() => {
          expect(controller.status).to.equal("READY")
          done()
        })
      })

      test("auto destroy controller", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // when:
          controller.remove()

          // then:
          expect(controller.status).to.equal("NOT-READY")
          done()
        })
      })

      test("change controller model", done => {
        // given:
        const controller = fixture("EmptyController")

        // when:
        controller.set("model", { fakeArray: {}, realArray: [] })
        controller.set("model.fakeArray.splices", "_splices")
        controller.set("model.fakeArray.length", "_length")
        controller.splice("model.realArray", 0, 0, ...[1, 3, 3, 7])

        setTimeout(() => {
          done()
        }, 20)

        // controller.set("model", { beanProp: "foo" })
        // controller.set("model.beanProp", "bar")
        // controller.set("model.arrayProp", [])
        // controller.set("model.arrayProp", [1, 2, 3, 4, 5])
        // controller.splice("model.arrayProp", 1, 3, ...[8, 9])

        // // https://www.polymer-project.org/2.0/docs/devguide/data-system#change-events
        // // https://www.polymer-project.org/2.0/docs/devguide/observers#array-observation

        // // then:
        // flush(() => {
        //   expect(controller.model).to.eql(
        //     { arrayProp: [1, 8, 9, 5], beanProp: "bar" }
        //   )
        //   controller.set("model.beanProp", null)
        //   controller.set("model.arrayProp", null)
        //   done()
        // })
      })
    })

    //----------------------------------------------------------------------------------------------
    // SUITE.
    //----------------------------------------------------------------------------------------------

    suite.skip("with client context mock", () => {
      setup(done => {
        window.clientContext = createClientContext()
        window.clientContext.onConnect().then(done)
      })

      teardown(done => {
        window.clientContext.disconnect().then(done)
      })

      test("change valueProperty", done => {
        const controller = fixture("EmptyController")
        controller.name = "FooController"
        controller.create()

        setTimeout(() => {
          console.log("--- root bean:", controller.model, controller._controller.model)

          // bean change.
          controller.model.valueProperty = "lorem ipsum dolor"
          const newValue1 = controller.model
          const oldValue1 = controller._notifyBeanPropertyChanged(newValue1, "valueProperty", "lorem ipsum dolor")
          console.log("--- bean change:", newValue1, oldValue1)

          setTimeout(() => {
            // bean change.
            controller.model.valueProperty = "lorem ipsum dolor 2"
            const newValue2 = controller.model
            const oldValue2 = controller._notifyBeanPropertyChanged(newValue2, "valueProperty", "lorem ipsum dolor 2")
            console.log("--- bean change:", newValue2, oldValue2)

            controller.destroy()
            done()
          }, 20)
        }, 20)
      })
    })

  })
</script>