<!-- ------------------------------------------------------------------------------------------ -->
<!-- IMPORTS.
<!-- ------------------------------------------------------------------------------------------ -->

<script src="../bower_components/webcomponentsjs/webcomponents-loader.js"></script>
<script src="../bower_components/web-component-tester/browser.js"></script>
<script src="../bower_components/dolphin-platform-js/dist/dolphin-platform.js"></script>
<link rel="import" href="../dolphin-controller.html">

<!-- ------------------------------------------------------------------------------------------ -->
<!-- FIXTURES.
<!-- ------------------------------------------------------------------------------------------ -->

<test-fixture id="EmptyController">
  <template>
    <dolphin-controller noauto></dolphin-controller>
  </template>
</test-fixture>

<test-fixture id="SimpleController">
  <template>
    <dolphin-controller name="SimpleController"></dolphin-controller>
  </template>
</test-fixture>

<!-- ------------------------------------------------------------------------------------------ -->
<!-- FEATURES.
<!-- ------------------------------------------------------------------------------------------ -->

<script>
  function createClientContext(done) {
    const clientContextFactory = new dolphin.ClientContextFactory()
    const clientContext = clientContextFactory.create("http://localhost:8080/dolphin")
    clientContext.onConnect().then(done)
    return clientContext
  }

  function createClientContextMock() {
    const clientContext = {
      _model: null,
      beanManager: {
        onBeanUpdate: () => null,
        onArrayUpdate: () => null,
        notifyBeanChange: () => null,
        notifyArrayChange: () => null,
      },
      createController: (name) => {
        let onDestroyedCallback
        return Promise.resolve({
          model: clientContext._model,
          destroy: () => {
            if (onDestroyedCallback) {
              onDestroyedCallback()
            }
          },
          onDestroyed: (callback) => {
            onDestroyedCallback = callback
          }
        })
      }
    }
    return clientContext
  }

  suite("<dolphin-controller>", () => {
    suite.only("bindings", () => {
      setup(() => {
        // setup:
        window.clientContext = createClientContextMock()
        window.clientContext._model = {
          arrayBean: {
            arrayProp: [0, { id: 1 }, { id: 2 }, 3, 4, 5]
          }
        }
      })

      test("binder update array", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          controller.splice("model.arrayBean.arrayProp", 2, 2, ...[10, 11, 12])
          controller.splice("model.arrayBean.arrayProp", 0, 10, ...[{ id: 13 }])
          // controller.set("model.arrayBean.arrayProp", [{ id: 14 }])
          done()
        })
      })
    })

    suite.skip("simple binding (array)", () => {
      // fixtures:
      let arrayBean

      setup(() => {
        // setup:
        arrayBean = { arrayProp: [1, 2, 3] }
        window.clientContext = createClientContextMock()
        window.clientContext._model = arrayBean
      })

      test("set the initial value", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // expect:
          expect(controller.model).to.eql(arrayBean)
          done()
        })
      })

      // https://github.com/domenic/sinon-chai#assertions
      test("update array element addition (from dolphin)", done => {
        // given:
        const controller = fixture("SimpleController")
        const onModelChangedSpy = sinon.spy(controller, "_onModelChanged")

        flush(() => {
          // when:
          controller._onBeanPropertyArrayChanged(arrayBean, "arrayProp", 1, 0, 99)

          // then:
          expect(onModelChangedSpy).to.have.been.calledWith({
            path: "model.arrayProp.slices",
            value: { arrayProp: [1, 99, 2, 3] },
            base: { arrayProp: [1, 99, 2, 3] }
          })
          console.log(JSON.stringify(onModelChangedSpy.args))
          console.log(JSON.stringify(onModelChangedSpy.getCall(0).args))

          expect(controller.model).to.eql({ arrayProp: [1, 99, 2, 3] })
          done()
        })
      })

      test("update array element removal (from dolphin)", done => {
        // given:
        const controller = fixture("SimpleController")
        const onModelChangedSpy = sinon.spy(controller, "_onModelChanged")

        console.log(sinon)

        flush(() => {
          // when:
          controller._onBeanPropertyArrayChanged(arrayBean, "arrayProp", 1, 0, 99)

          // then:
          expect(onModelChangedSpy).to.have.been.calledWith({
            path: "model.arrayProp.slices"
          })
          console.log(JSON.stringify(onModelChangedSpy.args))
          console.log(JSON.stringify(onModelChangedSpy.getCall(0).args))

          expect(controller.model).to.eql({ arrayProp: [1, 99, 2, 3] })
          done()
        })
      })
    })

    suite.skip("bean registry", () => {
      let controller
      setup(() => {
        // given:
        controller = fixture("EmptyController")
      })

      const fooBean = { stringProp: "foo" }
      const barBean = { stringProp: "bar" }

      test("initialize", () => {
        expect(controller._beanRegistry).to.eql(new Map())
      })

      test("query property paths", () => {
        controller._registerPropertyPath(fooBean, "model.selectedUser")

        expect(controller._queryPropertyPaths(fooBean)).to.eql(
          new Set(["model.selectedUser"]))
        expect(controller._queryPropertyPaths(barBean)).to.eql(
          new Set())
      })

      test("register property path", () => {
        controller._registerPropertyPath(fooBean, "model.selectedUser")
        controller._registerPropertyPath(barBean, "model.users.0")
        controller._registerPropertyPath(fooBean, "model.users.1")

        expect(controller._queryPropertyPaths(fooBean))
          .to.eql(new Set(["model.selectedUser", "model.users.1"]))
        expect(controller._queryPropertyPaths(barBean))
          .to.eql(new Set(["model.users.0"]))

        expect(controller._beanRegistry)
          .to.eql(new Map([
            [fooBean, new Set(["model.selectedUser", "model.users.1"])],
            [barBean, new Set(["model.users.0"])]
          ]))
      })

      test("unregister property path", () => {
        controller._registerPropertyPath(fooBean, "model.selectedUser")
        controller._registerPropertyPath(barBean, "model.users.0")
        controller._registerPropertyPath(fooBean, "model.users.1")

        controller._unregisterPropertyPath(fooBean, "model.selectedUser")
        controller._unregisterPropertyPath(fooBean, "model.users.1")

        expect(controller._queryPropertyPaths(fooBean))
          .to.eql(new Set())
        expect(controller._queryPropertyPaths(barBean))
          .to.eql(new Set(["model.users.0"]))

        expect(controller._beanRegistry)
          .to.eql(new Map([
            [barBean, new Set(["model.users.0"])]
          ]))
      })

      test("slice property path", () => {
        expect(controller._slicePropertyPath("model.users.1.firstName", 0, 1))
          .to.equal("model")
        expect(controller._slicePropertyPath("model.users.1.firstName", 1))
          .to.equal("users.1.firstName")
        expect(controller._slicePropertyPath("model.users.1.firstName", -1))
          .to.equal("firstName")
        expect(controller._slicePropertyPath("model.users.1.firstName", 0, -1))
          .to.equal("model.users.1")
        expect(controller._slicePropertyPath("model.users.1.firstName", 1, -1))
          .to.equal("users.1")

        expect(controller._slicePropertyPath("model.users.1.firstName", -2))
          .to.equal("1.firstName")
        expect(controller._slicePropertyPath("model.users.1.firstName", 0, -2))
          .to.equal("model.users")
      })
    })

    suite.skip("with client context", () => {
      setup(() => {
        window.clientContext = createClientContextMock()
      })

      test("set the initial value", done => {
        // given:
        const bean = { stringProp: "VALUE_1" }
        window.clientContext.createController = (name) => {
          return Promise.resolve({ model: bean, destroy: () => { } })
        }

        // when:
        const controller = fixture("SimpleController")

        // then:
        flush(() => {
          expect(controller.model).to.equal(bean)
          expect(controller.model.stringProp).to.equal("VALUE_1")
          done()
        })
      })

      test("synchronize changes coming from Dolphin", done => {
        // given:
        const bean = { stringProp: "VALUE_1" }
        window.clientContext._model = bean

        // when:
        const controller = fixture("EmptyController")

        // then:
        flush(() => {
          controller._onBeanPropertyChanged(bean, "stringProp", "VALUE_2", "VALUE_1")
          // sinon.assert.calledWithExactly(element.beanChangeObserver, { path: 'model.theProperty', value: 'VALUE_2', base: bean });
          done()
        })
      })

      test("create controller", done => {
        // given:
        const controller = fixture("EmptyController")
        controller.name = "EmptyController"

        // when:
        controller.create()

        // then:
        flush(() => {
          expect(controller.status).to.equal("READY")
          done()
        })
      })

      test("destroy controller", done => {
        // given:
        const controller = fixture("EmptyController")
        controller.name = "EmptyController"
        controller.create()

        // when:
        flush(() => {
          controller.destroy()

          // then:
          expect(controller.status).to.equal("NOT-READY")
          done()
        })
      })

      test("auto create controller", done => {
        // when:
        const controller = fixture("SimpleController")

        // then:
        flush(() => {
          expect(controller.status).to.equal("READY")
          done()
        })
      })

      test("auto destroy controller", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // when:
          controller.remove()

          // then:
          expect(controller.status).to.equal("NOT-READY")
          done()
        })
      })

      test("change controller model", done => {
        // given:
        const controller = fixture("EmptyController")

        // when:
        controller.set("model", { fakeArray: {}, realArray: [] })
        controller.set("model.fakeArray.splices", "_splices")
        controller.set("model.fakeArray.length", "_length")
        controller.splice("model.realArray", 0, 0, [1, 3, 3, 7])

        setTimeout(() => {
          done()
        }, 100)

        // controller.set("model", { beanProp: "foo" })
        // controller.set("model.beanProp", "bar")
        // controller.set("model.arrayProp", [])
        // controller.set("model.arrayProp", [1, 2, 3, 4, 5])
        // controller.splice("model.arrayProp", 1, 3, ...[8, 9])

        // // https://www.polymer-project.org/2.0/docs/devguide/data-system#change-events
        // // https://www.polymer-project.org/2.0/docs/devguide/observers#array-observation
        // // path, value, base = baseProperty

        // // then:
        // flush(() => {
        //   expect(controller.model).to.eql(
        //     { arrayProp: [1, 8, 9, 5], beanProp: "bar" }
        //   )
        //   controller.set("model.beanProp", null)
        //   controller.set("model.arrayProp", null)
        //   done()
        // })
      })
    })

    suite.skip("with client context mock", () => {
      setup(done => {
        window.clientContext = createClientContext(done)
      })

      test("change valueProperty", done => {
        const controller = fixture("EmptyController")
        controller.name = "FooController"
        controller.create()

        setTimeout(() => {
          // value change.
          console.log("--- value change", controller.model, controller._controller.model)
          controller.model.valueProperty = "lorem ipsum dolor"
          const oldValue = window.clientContext.beanManager.notifyBeanChange(controller.model, "valueProperty", "lorem ipsum dolor")
          console.log("oldValue:", oldValue)

          setTimeout(() => {
            // value change.
            console.log("--- value change", controller.model, controller._controller.model)

            controller.model.valueProperty = "lorem ipsum dolor 2"
            const oldValue2 = window.clientContext.beanManager.notifyBeanChange(controller.model, "valueProperty", "lorem ipsum dolor 2")
            console.log("oldValue2:", oldValue2)

            console.log("--- value change", controller.model, controller._controller.model)
            done()
          }, 200)
        }, 200)
      })
    })

  })
</script>