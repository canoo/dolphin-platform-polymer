<!-- ------------------------------------------------------------------------------------------ -->
<!-- IMPORTS.
<!-- ------------------------------------------------------------------------------------------ -->

<script src="../../webcomponentsjs/webcomponents-loader.js"></script>
<script src="../../web-component-tester/browser.js"></script>
<script src="../../core.js/client/shim.js"></script>
<script src="../../dolphin-platform-js/dist/dolphin-platform.js"></script>
<link rel="import" href="../dolphin-controller.html">

<!-- ------------------------------------------------------------------------------------------ -->
<!-- FIXTURES.
<!-- ------------------------------------------------------------------------------------------ -->

<test-fixture id="EmptyController">
  <template>
    <dolphin-controller no-create no-destroy></dolphin-controller>
  </template>
</test-fixture>

<test-fixture id="SimpleController">
  <template>
    <dolphin-controller name="SimpleController"></dolphin-controller>
  </template>
</test-fixture>

<!-- ------------------------------------------------------------------------------------------ -->
<!-- FEATURES.
<!-- ------------------------------------------------------------------------------------------ -->

<script>
  // mocha.checkLeaks()

  function pretty(value, padding = 2) {
    return JSON.stringify(value, null, padding)
  }

  function pretty1(value) {
    const string = pretty(value, 1)
    return string.split("\n").map(it => it.trim()).join(" ")
  }

  function pretty0(value) {
    return pretty(value, 0)
  }

  function createClientContext(url = "http://localhost:8080/dolphin") {
    const factory = new dolphin.ClientContextFactory()
    const config = {}
    return factory.create(url, config)
  }

  function createClientContextMock() {
    let onDestroyedCallback
    const clientContext = {
      _controller: {
        model: null,
        destroy: () => {
          if (onDestroyedCallback) {
            onDestroyedCallback()
          }
        },
        onDestroyed: (callback) => {
          onDestroyedCallback = callback
        }
      },
      beanManager: {
        onBeanUpdate: () => null,
        onArrayUpdate: () => null,
        notifyBeanChange: () => null,
        notifyArrayChange: () => null,
      },
      createController: (name) => {
        return Promise.resolve(clientContext._controller)
      }
    }
    return clientContext
  }

  suite("<dolphin-controller>", () => {

    //----------------------------------------------------------------------------------------------
    // SUITE.
    //----------------------------------------------------------------------------------------------

    suite("simple binding (of bean)", () => {
      // fixtures:
      let stringBean

      setup(() => {
        // setup:
        stringBean = { stringProp: "ONE" }
        window.clientContext = createClientContextMock()
        window.clientContext._controller.model = stringBean
      })

      test("initial bean (from dolphin)", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // expect:
          expect(controller.model).to.eql(stringBean)
          expect(controller.model.stringProp).to.eql("ONE")
          // TODO(hastebrot): expect notify bean property changed?
          done()
        })
      })

      test("changed bean property (from dolphin)", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // when:
          const onModelChangedSpy = sinon.spy(controller, "_onModelChanged")
          controller._onBeanPropertyChanged(stringBean, "stringProp", "TWO", "ONE")

          // then:
          expect(controller.model).to.eql(stringBean)
          expect(controller.model.stringProp).to.eql("TWO")

          // and:
          expect(onModelChangedSpy).to.have.been.calledWith({
            path: "model.stringProp",
            base: stringBean,
            value: "TWO"
          })
          done()
        })
      })

      test("changed bean property (from polymer)", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // when:
          const notifyBeanPropertyChangedSpy = sinon.spy(controller, "_notifyBeanPropertyChanged")
          controller.set("model.stringProp", "TWO")

          // then:
          expect(controller.model).to.eql(stringBean)
          expect(controller.model.stringProp).to.eql("TWO")

          // and:
          expect(notifyBeanPropertyChangedSpy).to.have.been.calledWith(
            stringBean, "stringProp", "TWO"
          )
          done()
        })
      })
    })

    //----------------------------------------------------------------------------------------------
    // SUITE.
    //----------------------------------------------------------------------------------------------

    suite("simple binding (of array)", () => {
      // fixtures:
      let arrayBean

      setup(() => {
        // setup:
        arrayBean = { arrayProp: [1, 2, 3, 4] }

        // and:
        window.clientContext = createClientContextMock()
        window.clientContext._controller.model = arrayBean
      })

      test("initial bean (from dolphin)", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // expect:
          expect(controller.model).to.eql(arrayBean)
          expect(controller.model.arrayProp).to.eql([1, 2, 3, 4])
          done()
        })
      })

      test("spliced bean property with added items (from dolphin)", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // when:
          const onModelChangedSpy = sinon.spy(controller, "_onModelChanged")
          controller._onBeanPropertySpliced(arrayBean, "arrayProp", 1, 0, [10, 11])

          // then:
          expect(controller.model).to.eql(arrayBean)
          expect(controller.model.arrayProp).to.eql([1, 10, 11, 2, 3, 4])

          // and:
          expect(onModelChangedSpy).to.have.been.calledWith({
            path: "model.arrayProp.splices",
            base: arrayBean,
            value: {
              indexSplices: [{
                index: 1,
                addedCount: 2,
                removed: [],
                object: [1, 10, 11, 2, 3, 4],
                type: "splice"
              }]
            }
          })
          done()
        })
      })

      test("spliced bean property with removed items (from dolphin)", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // when:
          const onModelChangedSpy = sinon.spy(controller, "_onModelChanged")
          controller._onBeanPropertySpliced(arrayBean, "arrayProp", 1, 2, [])

          // then:
          expect(controller.model).to.eql(arrayBean)
          expect(controller.model.arrayProp).to.eql([1, 4])

          // and:
          expect(onModelChangedSpy).to.have.been.calledWith({
            path: "model.arrayProp.splices",
            base: arrayBean,
            value: {
              indexSplices: [{
                index: 1,
                addedCount: 0,
                removed: [2, 3],
                object: [1, 4],
                type: "splice"
              }]
            }
          })
          done()
        })
      })

      test("spliced bean property with replaced items (from dolphin)", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // when:
          const onModelChangedSpy = sinon.spy(controller, "_onModelChanged")
          controller._onBeanPropertySpliced(arrayBean, "arrayProp", 1, 2, [10, 11])

          // then:
          expect(controller.model).to.eql(arrayBean)
          expect(controller.model.arrayProp).to.eql([1, 10, 11, 4])

          // and:
          expect(onModelChangedSpy).to.have.been.calledWith({
            path: "model.arrayProp.splices",
            base: arrayBean,
            value: {
              indexSplices: [{
                index: 1,
                addedCount: 2,
                removed: [2, 3],
                object: [1, 10, 11, 4],
                type: "splice"
              }]
            }
          })
          done()
        })
      })

      test("spliced bean property with added items (from polymer)", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // when:
          const notifyBeanPropertySplicedSpy = sinon.spy(controller, "_notifyBeanPropertySpliced")
          controller.splice("model.arrayProp", 1, 0, ...[10, 11])

          // then:
          expect(controller.model).to.eql(arrayBean)
          expect(controller.model.arrayProp).to.eql([1, 10, 11, 2, 3, 4])

          // and:
          expect(notifyBeanPropertySplicedSpy).to.have.been.calledWith(
            arrayBean, "arrayProp", 1, [], 2
          )
          done()
        })
      })

      test("spliced bean property with removed items (from polymer)", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // when:
          const notifyBeanPropertySplicedSpy = sinon.spy(controller, "_notifyBeanPropertySpliced")
          controller.splice("model.arrayProp", 1, 2, ...[])

          // then:
          expect(controller.model).to.eql(arrayBean)
          expect(controller.model.arrayProp).to.eql([1, 4])

          // and:
          expect(notifyBeanPropertySplicedSpy).to.have.been.calledWith(
            arrayBean, "arrayProp", 1, [2, 3], 0
          )
          done()
        })
      })

      test("spliced bean property with replaced items (from polymer)", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // when:
          const notifyBeanPropertySplicedSpy = sinon.spy(controller, "_notifyBeanPropertySpliced")
          controller.splice("model.arrayProp", 1, 2, ...[10, 11])

          // then:
          expect(controller.model).to.eql(arrayBean)
          expect(controller.model.arrayProp).to.eql([1, 10, 11, 4])

          // and:
          expect(notifyBeanPropertySplicedSpy).to.have.been.calledWith(
            arrayBean, "arrayProp", 1, [2, 3], 2
          )
          done()
        })
      })
    })

    //----------------------------------------------------------------------------------------------
    // SUITE.
    //----------------------------------------------------------------------------------------------

    suite("deep binding (of nested bean in bean)", () => {
      // fixtures:
      let beanBean
      let stringBean
      let otherStringBean

      setup(() => {
        // setup:
        stringBean = { stringProp: "ONE" }
        otherStringBean = { stringProp: "OTHER_ONE" }
        beanBean = { beanProp: stringBean }

        // and:
        window.clientContext = createClientContextMock()
        window.clientContext._controller.model = beanBean
      })

      test("from dolphin: changed root bean", done => {
        // given:
        const controller = fixture("SimpleController")
        const onModelChangedSpy = sinon.spy(controller, "_onModelChanged")

        flush(() => {
          // expect:
          expect(controller.model).to.eql(beanBean)
          expect(controller.model.beanProp).to.eql(stringBean)
          expect(controller.model.beanProp.stringProp).to.eql("ONE")

          // and:
          expect(onModelChangedSpy).to.have.been.calledWith({
            path: "model",
            base: beanBean,
            value: beanBean
          })
          done()
        })
      })

      test("from dolphin: changed bean property of bean", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // when:
          const onModelChangedSpy = sinon.spy(controller, "_onModelChanged")
          controller._onBeanPropertyChanged(beanBean, "beanProp", otherStringBean, stringBean)

          // then:
          expect(controller.model).to.eql(beanBean)
          expect(controller.model.beanProp).to.eql(otherStringBean)
          expect(controller.model.beanProp.stringProp).to.eql("OTHER_ONE")

          // and:
          expect(onModelChangedSpy).to.have.been.calledWith({
            path: "model.beanProp",
            base: beanBean,
            value: otherStringBean
          })
          done()
        })
      })

      test("from dolphin: changed bean property of nested bean", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // when:
          const onModelChangedSpy = sinon.spy(controller, "_onModelChanged")
          controller._onBeanPropertyChanged(stringBean, "stringProp", "TWO", "ONE")

          // then:
          expect(controller.model).to.eql(beanBean)
          expect(controller.model.beanProp).to.eql(stringBean)
          expect(controller.model.beanProp.stringProp).to.eql("TWO")

          // and:
          expect(onModelChangedSpy).to.have.been.calledWith({
            path: "model.beanProp.stringProp",
            base: beanBean,
            value: "TWO"
          })
          done()
        })
      })

      test("from dolphin: changed bean property of dolphin re-bound nested bean", done => {
        // given:
        const controller = fixture("SimpleController")
        const onModelChangedSpy = sinon.spy(controller, "_onModelChanged")
        const notifyBeanPropertyChangedStub = sinon.stub(controller, "_notifyBeanPropertyChanged")

        flush(() => {
          // and:
          notifyBeanPropertyChangedStub.returns(stringBean)
          controller._onBeanPropertyChanged(beanBean, "beanProp", otherStringBean, stringBean)

          // when:
          onModelChangedSpy.reset()
          controller._onBeanPropertyChanged(stringBean, "stringProp", "TWO", "ONE")

          // then:
          expect(onModelChangedSpy).to.have.callCount(0)

          // when:
          onModelChangedSpy.reset()
          notifyBeanPropertyChangedStub.returns("OTHER_ONE")
          controller._onBeanPropertyChanged(otherStringBean, "stringProp", "OTHER_TWO", "OTHER_ONE")

          // then:
          expect(onModelChangedSpy).to.have.been.calledWith({
            path: "model.beanProp.stringProp",
            base: beanBean,
            value: "OTHER_TWO"
          })
          done()
        })
      })

      test("from dolphin: changed bean property of polymer re-bound nested bean", done => {
        // given:
        const controller = fixture("SimpleController")
        const onModelChangedSpy = sinon.spy(controller, "_onModelChanged")
        const notifyBeanPropertyChangedStub = sinon.stub(controller, "_notifyBeanPropertyChanged")

        flush(() => {
          // and:
          notifyBeanPropertyChangedStub.returns(stringBean)
          controller.set("model.beanProp", otherStringBean)

          // when:
          onModelChangedSpy.reset()
          controller._onBeanPropertyChanged(stringBean, "stringProp", "TWO", "ONE")

          // then:
          expect(onModelChangedSpy).to.have.callCount(0)

          // when:
          onModelChangedSpy.reset()
          notifyBeanPropertyChangedStub.returns("OTHER_ONE")
          controller._onBeanPropertyChanged(otherStringBean, "stringProp", "OTHER_TWO", "OTHER_ONE")

          // then:
          expect(onModelChangedSpy).to.have.been.calledWith({
            path: "model.beanProp.stringProp",
            base: beanBean,
            value: "OTHER_TWO"
          })
          done()
        })
      })

      // HERE:
      test("from polymer: changed bean property of bean", done => {
        // given:
        const controller = fixture("SimpleController")
        const notifyBeanPropertyChangedStub = sinon.stub(controller, "_notifyBeanPropertyChanged")

        flush(() => {
          // when:
          notifyBeanPropertyChangedStub.returns(stringBean)
          controller.set("model.beanProp", otherStringBean)

          // then:
          expect(controller.model).to.eql(beanBean)
          expect(controller.model.beanProp).to.eql(otherStringBean)
          expect(controller.model.beanProp.stringProp).to.eql("OTHER_ONE")

          // and:
          expect(notifyBeanPropertyChangedStub).to.have.been.calledWith(
            beanBean, "beanProp", otherStringBean
          )
          done()
        })
      })

      test("from polymer: changed bean property of nested bean", done => {
        // given:
        const controller = fixture("SimpleController")
        const notifyBeanPropertyChangedStub = sinon.stub(controller, "_notifyBeanPropertyChanged")

        flush(() => {
          // when:
          notifyBeanPropertyChangedStub.returns("ONE")
          controller.set("model.beanProp.stringProp", "TWO")

          // then:
          expect(controller.model).to.eql(beanBean)
          expect(controller.model.beanProp).to.eql(stringBean)
          expect(controller.model.beanProp.stringProp).to.eql("TWO")

          // and:
          expect(notifyBeanPropertyChangedStub).to.have.been.calledWith(
            stringBean, "stringProp", "TWO"
          )
          done()
        })
      })

      test("from polymer: changed bean property of dolphin re-bound nested bean", done => {
        // given:
        const controller = fixture("SimpleController")
        const notifyBeanPropertyChangedStub = sinon.stub(controller, "_notifyBeanPropertyChanged")

        flush(() => {
          // and:
          notifyBeanPropertyChangedStub.returns(stringBean)
          controller._onBeanPropertyChanged(beanBean, "beanProp", otherStringBean, stringBean)

          // when:
          notifyBeanPropertyChangedStub.reset()
          controller._onBeanPropertyChanged(stringBean, "stringProp", "TWO", "ONE")

          // then:
          expect(notifyBeanPropertyChangedStub).to.have.callCount(0)

          // when:
          notifyBeanPropertyChangedStub.reset()
          notifyBeanPropertyChangedStub.returns("OTHER_ONE")
          controller._onBeanPropertyChanged(otherStringBean, "stringProp", "OTHER_TWO", "OTHER_ONE")

          // then:
          expect(notifyBeanPropertyChangedStub).to.have.been.calledWith(
            otherStringBean, "stringProp", "OTHER_TWO"
          )
          done()
        })
      })

      test("from polymer: changed bean property of polymer re-bound nested bean", done => {
        // given:
        const controller = fixture("SimpleController")
        const notifyBeanPropertyChangedStub = sinon.stub(controller, "_notifyBeanPropertyChanged")

        flush(() => {
          // and:
          notifyBeanPropertyChangedStub.returns(stringBean)
          controller.set("model.beanProp", otherStringBean)

          // when:
          notifyBeanPropertyChangedStub.reset()
          controller._onBeanPropertyChanged(stringBean, "stringProp", "TWO", "ONE")

          // then:
          expect(notifyBeanPropertyChangedStub).to.have.callCount(0)

          // when:
          notifyBeanPropertyChangedStub.reset()
          notifyBeanPropertyChangedStub.returns("OTHER_ONE")
          controller._onBeanPropertyChanged(otherStringBean, "stringProp", "OTHER_TWO", "OTHER_ONE")

          // then:
          expect(notifyBeanPropertyChangedStub).to.have.been.calledWith(
            otherStringBean, "stringProp", "OTHER_TWO"
          )
          done()
        })
      })
    })

    //----------------------------------------------------------------------------------------------
    // SUITE.
    //----------------------------------------------------------------------------------------------

    suite("dolphin action (simple invoke)", () => {
      setup(() => {
        // setup:
        window.clientContext = createClientContextMock()
      })

      test("invoke action without parameters", done => {
        // given:
        const controller = fixture("SimpleController")
        window.clientContext._controller.invoke = sinon.stub()
          .returns(Promise.resolve("simpleActionResult"))

        flush(() => {
          // expect:
          controller.invoke("simpleAction").then(result => {
            expect(result).to.eql("simpleActionResult")
            done()
          })
        })
      })

      test("invoke action with named parameters", done => {
        // given:
        const controller = fixture("SimpleController")
        window.clientContext._controller.invoke = sinon.stub()
          .withArgs("simpleAction", { numberParam: 1 })
          .returns(Promise.resolve("simpleActionResult"))

        flush(() => {
          // expect:
          controller.invoke("simpleAction", { numberParam: 1 }).then(result => {
            expect(result).to.eql("simpleActionResult")
            done()
          })
        })
      })
    })

    //----------------------------------------------------------------------------------------------
    // SUITE.
    //----------------------------------------------------------------------------------------------

    suite("bean registry", () => {
      let controller
      setup(() => {
        // setup:
        controller = fixture("EmptyController")
      })

      const fooBean = { stringProp: "foo" }
      const barBean = { stringProp: "bar" }

      test("initialize", () => {
        // expect:
        expect(controller._beanRegistry).to.eql(new Map())
      })

      test("query property paths", () => {
        // given:
        controller._registerPropertyPath(fooBean, "model.selectedUser")

        // expect:
        expect(controller._queryPropertyPaths(fooBean)).to.eql(
          new Set(["model.selectedUser"]))
        expect(controller._queryPropertyPaths(barBean)).to.eql(
          new Set())
      })

      test("register property path", () => {
        // given:
        controller._registerPropertyPath(fooBean, "model.selectedUser")
        controller._registerPropertyPath(barBean, "model.users.0")
        controller._registerPropertyPath(fooBean, "model.users.1")

        // expect:
        expect(controller._queryPropertyPaths(fooBean))
          .to.eql(new Set(["model.selectedUser", "model.users.1"]))
        expect(controller._queryPropertyPaths(barBean))
          .to.eql(new Set(["model.users.0"]))

        // and:
        expect(controller._beanRegistry)
          .to.eql(new Map([
            [fooBean, new Set(["model.selectedUser", "model.users.1"])],
            [barBean, new Set(["model.users.0"])]
          ]))
      })

      test("unregister property path", () => {
        // given:
        controller._registerPropertyPath(fooBean, "model.selectedUser")
        controller._registerPropertyPath(barBean, "model.users.0")
        controller._registerPropertyPath(fooBean, "model.users.1")

        // and:
        controller._unregisterPropertyPath(fooBean, "model.selectedUser")
        controller._unregisterPropertyPath(fooBean, "model.users.1")

        // expect:
        expect(controller._queryPropertyPaths(fooBean))
          .to.eql(new Set())
        expect(controller._queryPropertyPaths(barBean))
          .to.eql(new Set(["model.users.0"]))

        // and:
        expect(controller._beanRegistry)
          .to.eql(new Map([
            [barBean, new Set(["model.users.0"])]
          ]))
      })

      test("slice property path", () => {
        // expect:
        expect(controller._slicePropertyPath("model.users.1.firstName", 0, 1))
          .to.equal("model")
        expect(controller._slicePropertyPath("model.users.1.firstName", 1))
          .to.equal("users.1.firstName")
        expect(controller._slicePropertyPath("model.users.1.firstName", -1))
          .to.equal("firstName")
        expect(controller._slicePropertyPath("model.users.1.firstName", 0, -1))
          .to.equal("model.users.1")
        expect(controller._slicePropertyPath("model.users.1.firstName", 1, -1))
          .to.equal("users.1")

        // and:
        expect(controller._slicePropertyPath("model.users.1.firstName", -2))
          .to.equal("1.firstName")
        expect(controller._slicePropertyPath("model.users.1.firstName", 0, -2))
          .to.equal("model.users")
      })
    })

    //----------------------------------------------------------------------------------------------
    // SUITE.
    //----------------------------------------------------------------------------------------------

    suite.skip("bean registry bindings", () => {
      setup(() => {
        // setup:
        window.clientContext = createClientContextMock()
        window.clientContext._controller.model = {
          arrayBean: {
            arrayProp: [0, { id: 1 }, { id: 2 }, 3, 4, 5]
          }
        }
      })

      test("bind bean array", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // expect:
          controller.splice("model.arrayBean.arrayProp", 2, 2, ...[10, 11, 12])
          controller.splice("model.arrayBean.arrayProp", 0, 10, ...[{ id: 13 }])
          // controller.set("model.arrayBean.arrayProp", [{ id: 14 }])
          done()
        })
      })
    })

    //----------------------------------------------------------------------------------------------
    // SUITE.
    //----------------------------------------------------------------------------------------------

    suite.skip("with client context mock", () => {
      setup(() => {
        // setup:
        window.clientContext = createClientContextMock()
      })

      test("creates controller", done => {
        // when:
        const controller = fixture("SimpleController")

        flush(() => {
          // then:
          expect(controller.status).to.equal("READY")
          done()
        })
      })

      test("destroys controller", done => {
        // given:
        const controller = fixture("SimpleController")

        flush(() => {
          // when:
          controller.remove()

          // then:
          expect(controller.status).to.equal("NOT-READY")
          done()
        })
      })

      test("with create controller", done => {
        // given:
        const controller = fixture("EmptyController")
        controller.name = "EmptyController"

        // when:
        controller.create()

        flush(() => {
          // then:
          expect(controller.status).to.equal("READY")
          done()
        })
      })

      test("with destroy controller", done => {
        // given:
        const controller = fixture("EmptyController")
        controller.name = "EmptyController"
        controller.create()

        flush(() => {
          // when:
          controller.destroy()

          // then:
          expect(controller.status).to.equal("NOT-READY")
          done()
        })
      })
    })

  })
</script>