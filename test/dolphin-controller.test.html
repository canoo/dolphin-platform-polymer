<!-- ------------------------------------------------------------------------------------------ -->
<!-- IMPORTS.
<!-- ------------------------------------------------------------------------------------------ -->

<script src="../bower_components/webcomponentsjs/webcomponents-loader.js"></script>
<script src="../bower_components/web-component-tester/browser.js"></script>
<script src="../bower_components/dolphin-platform-js/dist/dolphin-platform.js"></script>
<link rel="import" href="../dolphin-controller.html">

<!-- ------------------------------------------------------------------------------------------ -->
<!-- FIXTURES.
<!-- ------------------------------------------------------------------------------------------ -->

<test-fixture id="EmptyController">
  <template>
    <dolphin-controller></dolphin-controller>
  </template>
</test-fixture>

<test-fixture id="SimpleController">
  <template>
    <dolphin-controller auto name="SimpleController"></dolphin-controller>
  </template>
</test-fixture>

<!-- ------------------------------------------------------------------------------------------ -->
<!-- FEATURES.
<!-- ------------------------------------------------------------------------------------------ -->

<script>
  suite("<dolphin-controller>", () => {
    suite("bean registry", () => {
      let controller
      setup(() => {
        // given:
        controller = fixture("EmptyController")
      })

      const fooBean = { stringProp: "foo" }
      const barBean = { stringProp: "bar" }

      test("initialize", () => {
        expect(controller._beanRegistry).to.eql(new Map())
      })

      test("query property paths", () => {
        controller._registerPropertyPath(fooBean, "model.selectedUser")

        expect(controller._queryPropertyPaths(fooBean)).to.eql(
          new Set(["model.selectedUser"]))
        expect(controller._queryPropertyPaths(barBean)).to.eql(
          new Set())
      })

      test("register property path", () => {
        controller._registerPropertyPath(fooBean, "model.selectedUser")
        controller._registerPropertyPath(barBean, "model.users.0")
        controller._registerPropertyPath(fooBean, "model.users.1")

        expect(controller._queryPropertyPaths(fooBean))
          .to.eql(new Set(["model.selectedUser", "model.users.1"]))
        expect(controller._queryPropertyPaths(barBean))
          .to.eql(new Set(["model.users.0"]))

        expect(controller._beanRegistry)
          .to.eql(new Map([
            [fooBean, new Set(["model.selectedUser", "model.users.1"])],
            [barBean, new Set(["model.users.0"])]
          ]))
      })

      test("unregister property path", () => {
        controller._registerPropertyPath(fooBean, "model.selectedUser")
        controller._registerPropertyPath(barBean, "model.users.0")
        controller._registerPropertyPath(fooBean, "model.users.1")

        controller._unregisterPropertyPath(fooBean, "model.selectedUser")
        controller._unregisterPropertyPath(fooBean, "model.users.1")

        expect(controller._queryPropertyPaths(fooBean))
          .to.eql(new Set())
        expect(controller._queryPropertyPaths(barBean))
          .to.eql(new Set(["model.users.0"]))

        expect(controller._beanRegistry)
          .to.eql(new Map([
            [barBean, new Set(["model.users.0"])]
          ]))
      })
    })
  })

  suite.skip("<dolphin-controller>", () => {
    setup(done => {
      const clientContextFactory = new dolphin.ClientContextFactory()
      const clientContext = clientContextFactory.create("http://localhost:8080/dolphin")
      clientContext.onConnect().then(done)
      window.clientContext = clientContext
    })

    test("with server connection", done => {
      const controller = fixture("EmptyController")
      controller.name = "FooController"
      controller.create()

      setTimeout(() => {
        // value change.
        console.log("--- value change", controller.model, controller._controller.model)
        controller.model.valueProperty = "lorem ipsum dolor"
        const oldValue = window.clientContext.beanManager.notifyBeanChange(controller.model, "valueProperty", "lorem ipsum dolor")
        console.log("oldValue:", oldValue)

        setTimeout(() => {
          // value change.
          console.log("--- value change", controller.model, controller._controller.model)

          controller.model.valueProperty = "lorem ipsum dolor 2"
          const oldValue2 = window.clientContext.beanManager.notifyBeanChange(controller.model, "valueProperty", "lorem ipsum dolor 2")
          console.log("oldValue2:", oldValue2)

          console.log("--- value change", controller.model, controller._controller.model)
          done()
        }, 200)
      }, 200)
    })
  })

  suite("<dolphin-controller>", () => {
    setup(() => {
      const clientContext = {
        beanManager: {
          onBeanUpdate: (callback) => { },
          onArrayUpdate: (callback) => { },
          notifyBeanChange: () => { },
          notifyArrayChange: () => { },
        },
        createController: (name) => {
          let onDestroyedCallback
          return Promise.resolve({
            model: {},
            destroy: () => {
              if (onDestroyedCallback) {
                onDestroyedCallback()
              }
            },
            onDestroyed: (callback) => {
              onDestroyedCallback = callback
            }
          })
        }
      }
      window.clientContext = clientContext
    })

    test("set the initial value", done => {
      // given:
      const bean = { stringProp: "VALUE_1" }
      window.clientContext.createController = (name) => {
        return Promise.resolve({ model: bean, destroy: () => { } })
      }

      // when:
      const controller = fixture("SimpleController")

      // then:
      flush(() => {
        expect(controller.model).to.equal(bean)
        expect(controller.model.stringProp).to.equal("VALUE_1")
        done()
      })
    })

    test("synchronize changes coming from Dolphin", done => {
      // given:
      const bean = { stringProp: "VALUE_1" }
      window.clientContext.createController = (name) => {
        return Promise.resolve({ model: bean, destroy: () => { } })
      }

      // when:
      const controller = fixture("EmptyController")

      // then:
      flush(() => {
        controller._onBeanPropertyChanged(bean, "stringProp", "VALUE_2", "VALUE_1")
        // sinon.assert.calledWithExactly(element.beanChangeObserver, { path: 'model.theProperty', value: 'VALUE_2', base: bean });
        done()
      })
    })

    // it('should synchronize changes coming from Polymer', sinon.test(function (done) {
    //   var bean = { theProperty: 'VALUE_1' };
    //   clientContext.createController = this.stub().returns(Promise.resolve({ model: bean, onDestroyed: function () { } }));
    //   var element = new CustomElement();
    //   var notifyBeanChangeStub = this.stub(clientContext.beanManager, 'notifyBeanChange');
    //   notifyBeanChangeStub.returns('VALUE_1');

    //   check(done, function () {
    //     element.set('model.theProperty', 'VALUE_2');
    //     sinon.assert.calledWithExactly(clientContext.beanManager.notifyBeanChange, bean, 'theProperty', 'VALUE_2');
    //   });
    // }));

    test("create controller", done => {
      // given:
      const controller = fixture("EmptyController")
      controller.name = "EmptyController"

      // when:
      controller.create()

      // then:
      flush(() => {
        expect(controller.state).to.equal("READY")
        done()
      })
    })

    test("destroy controller", done => {
      // given:
      const controller = fixture("EmptyController")
      controller.name = "EmptyController"
      controller.create()

      // when:
      flush(() => {
        controller.destroy()

        // then:
        expect(controller.state).to.equal("NOT-READY")
        done()
      })
    })

    test("auto create controller", done => {
      // when:
      const controller = fixture("SimpleController")

      // then:
      flush(() => {
        expect(controller.state).to.equal("READY")
        done()
      })
    })

    test("auto destroy controller", done => {
      // given:
      const controller = fixture("SimpleController")

      flush(() => {
        // when:
        controller.remove()

        // then:
        expect(controller.state).to.equal("NOT-READY")
        done()
      })
    })

    test("change controller model", done => {
      // given:
      const controller = fixture("EmptyController")

      // when:
      controller.set("model", { beanProp: "foo" })
      controller.set("model.beanProp", "bar")
      controller.set("model.arrayProp", [])
      controller.set("model.arrayProp", [1, 2, 3, 4, 5])
      controller.splice("model.arrayProp", 1, 3, ...[8, 9])

      // then:
      flush(() => {
        expect(controller.model).to.eql(
          { arrayProp: [1, 8, 9, 5], beanProp: "bar" }
        )
        done()
      })
    })
  })
</script>