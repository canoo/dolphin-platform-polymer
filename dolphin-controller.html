<!--
@license
Copyright 2017 Canoo Engineering AG.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="./bower_components/polymer/polymer-element.html">

<dom-module id="dolphin-controller">

  <script>
    const STATUS_NOT_READY = "NOT-READY"
    const STATUS_READY = "READY"

    /**
     * @customElement
     * @polymer
     */
    class DolphinController extends Polymer.Element {
      static get is() {
        return "dolphin-controller"
      }

      static get properties() {
        return {
          clientContext: {
            type: Object,
            value: () => window.clientContext
          },
          auto: {
            type: Boolean,
            value: false
          },
          state: {
            type: String,
            value: STATUS_NOT_READY
          },
          name: String,
          model: Object
        }
      }

      static get observers() {
        return [
          "_onClientContextChanged(clientContext)",
          "_onModelChanged(model.*)"
        ]
      }

      constructor() {
        super()
        this._beanRegistry = new Map()
      }

      connectedCallback() {
        super.connectedCallback()
        if (isTruthy(this.auto)) {
          this.create()
        }
      }

      disconnectedCallback() {
        super.disconnectedCallback()
        if (isTruthy(this.auto)) {
          this.destroy()
        }
      }

      create() {
        if (!isNil(this.clientContext) && !isNil(this.name)) {
          this._onControllerInitializing()
          this.clientContext.createController(this.name)
            .then(controller => {
              this._onControllerReady(controller)
              // controller.onDestroyed(() => {
              //   this._onControllerDestroyed(controller)
              // })
            })
        }
      }

      destroy() {
        if (!isNil(this._controller)) {
          this._controller.destroy()
        }
      }

      _onClientContextChanged() {
        if (!isNil(this.clientContext)) {
          this._beanManager = this.clientContext.beanManager
          this._beanManager.onBeanUpdate(this._onReceiveDolphinBeanUpdate.bind(this))
          this._beanManager.onArrayUpdate(this._onReceiveDolphinBeanArrayUpdate.bind(this))
        }
      }

      _onControllerInitializing() {
        console.log("_onControllerInitializing()", this.name)
        this._controller = null
        this.state = STATUS_NOT_READY
      }

      _onControllerReady(controller) {
        console.log("_onControllerReady()", this.name, controller)
        this._controller = controller
        this.state = STATUS_READY
        this._onReceiveDolphinBeanInitial(this._controller.model)
      }

      _onControllerDestroyed(controller) {
        console.log("_onControllerDestroyed()", this.name, controller)
        this._controller = null
        this.state = STATUS_NOT_READY
      }

      /**
       * Receives changes of the `model` property and its subproperties.
       */
      _onModelChanged(event) {
        const propertyPath = event.path
        const newValue = event.value
        console.log("here", event)
        if (!isNil(newValue) && !isNil(newValue.indexSplices)) {
          this._onModelBeanArrayChanged(propertyPath, newValue)
        }
        else {
          this._onModelBeanChanged(propertyPath, newValue)
        }
      }

      /**
       * Notifies the Dolphin server about bean changes.
       */
      _notifyBeanChanged(propertyPath, newValue) {
        console.log("notify bean changed:", propertyPath, newValue)
        const bean = this.get(propertyPath)
        const propertyName = last(Polymer.Path.split(propertyPath))
        console.log("-->", propertyName, bean)

        const oldValue = this._beanManager.notifyBeanChange(bean, propertyName, newValue)
        this._beanManager.notifyArrayChange(bean, propertyName, startIndex, addedCount, removedItems)
      }

      /**
       * Notifies the Dolphin server about bean array changes.
       */
      _notifyBeanArrayChanged(propertyPath, newValue) {
        console.log("notify bean array changed:", propertyPath, newValue)
        const _propertyPath = propertyPath.substr(0, propertyPath.length - ".splices".length);
        const _newValue = newValue.indexSplices[0].object
        const startIndex = newValue.indexSplices[0].index
        const addedCount = newValue.indexSplices[0].addedCount
        const removedItems = newValue.indexSplices[0].removed
        console.log("-->", _propertyPath, _newValue, startIndex, addedCount, removedItems)
      }

      /**
       * Receives an initial bean from the Dolphin server.
       */
      _onBeanChanged(bean) {
        console.log("on bean changed", bean)
        this.set("model", bean)
      }

      /**
       * Receives a bean property change from the Dolphin server.
       */
      _onBeanPropertyChanged(bean, propertyName, newValue, oldValue) {
        console.log("on bean property changed:",
          bean, propertyName, newValue, oldValue)
      }

      /**
       * Receives a bean property array change from the Dolphin server.
       */
      _onBeanPropertyArrayChanged(bean, propertyName, startIndex, removedCount, addedItems) {
        console.log("on bean property array changed:",
          bean, propertyName, startIndex, removedCount, addedItems)
      };

      _queryPropertyPaths(bean) {
        return this._beanRegistry.get(bean) || new Set()
      }

      _registerPropertyPath(bean, propertyPath) {
        const propertyPaths = this._queryPropertyPaths(bean)
        if (propertyPaths.size === 0) {
          this._beanRegistry.set(bean, propertyPaths)
        }
        propertyPaths.add(propertyPath)
      }

      _unregisterPropertyPath(bean, propertyPath) {
        const propertyPaths = this._queryPropertyPaths(bean)
        propertyPaths.delete(propertyPath)
        if (propertyPaths.size === 0) {
          this._beanRegistry.delete(bean)
        }
      }
    }

    window.customElements.define(DolphinController.is, DolphinController)

    function isNil(value) {
      return value === null || value === undefined
    }

    function isTruthy(value) {
      return !!value
    }

    function last(array) {
      return array.slice(-1)[0]
    }
  </script>

</dom-module>