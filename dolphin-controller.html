<!--
@license
Copyright 2017 Canoo Engineering AG.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="./bower_components/polymer/polymer-element.html">

<dom-module id="dolphin-controller">

  <script>
    const STATUS_NOT_READY = "NOT-READY"
    const STATUS_READY = "READY"

    /**
     * The `dolphin-controller` element serves as a Dolphin controller.
     *
     * ~~~html
     * <dolphin-controller
     *   auto
     *   name="MovieController"
     *   model="{{hostModel}}"></dolphin-controller>
     * ~~~
     *
     * With `auto` set to `true`, the element automatically creates and destroys a
     * Dolphin controller, when it is attached or detached from the DOM tree.
     *
     * @customElement
     * @polymer
     */
    class DolphinController extends Polymer.Element {
      static get is() {
        return "dolphin-controller"
      }

      static get properties() {
        return {
          /**
           * The `ClientContext` of the Dolphin JavaScript client, which should be already
           * connected. Defaults to `window.clientContext`.
           */
          clientContext: {
            type: Object,
            value: () => window.clientContext
          },

          /**
           * If true, automatically creates and destroys a Dolphin controller, when the
           * element is attached or detached from the DOM tree.
           */
          auto: {
            type: Boolean,
            value: false
          },

          /**
           * The status of the Dolphin controller. Either "READY" or "NOT-READY". Initially
           * is set to "NOT-READY".
           */
          status: {
            type: String,
            value: STATUS_NOT_READY
          },

          /**
           * The name of the Dolphin controller.
           */
          name: String,

          /**
           * The model object graph. Receives changes from Dolphin and notifies Dolphin
           * when was changed.
           *
           * @type {Object}
           */
          model: Object
        }
      }

      static get observers() {
        return [
          "_onClientContextChanged(clientContext)",
          "_onModelChanged(model.*)"
        ]
      }

      constructor() {
        super()
        this._beanRegistry = new Map()
      }

      connectedCallback() {
        super.connectedCallback()
        if (isTruthy(this.auto)) {
          this.create()
        }
      }

      disconnectedCallback() {
        super.disconnectedCallback()
        if (isTruthy(this.auto)) {
          this.destroy()
        }
      }

      /**
       * Creates a Dolphin controller.
       */
      create() {
        if (!isNil(this.clientContext) && !isNil(this.name)) {
          this._onControllerInitializing()
          this.clientContext.createController(this.name)
            .then(controller => {
              this._onControllerReady(controller)
              if (!isNil(controller.onDestroyed)) {
                controller.onDestroyed(() => {
                  this._onControllerDestroyed(controller)
                })
              }
            })
        }
      }

      /**
       * Destroys a Dolphin controller.
       */
      destroy() {
        if (!isNil(this._controller)) {
          this._controller.destroy()
        }
      }

      /**
       * Called when the controller is initializing.
       */
      _onControllerInitializing() {
        this._controller = null
        this.status = STATUS_NOT_READY
      }

      /**
       * Called when the controller is ready.
       */
      _onControllerReady(controller) {
        this._controller = controller
        this._onBeanChanged(this._controller.model)
        this.status = STATUS_READY
      }

      /**
       * Called when the controller is destroyed.
       */
      _onControllerDestroyed(controller) {
        this._controller = null
        this.status = STATUS_NOT_READY
      }

      /**
       *
       */
      _onClientContextChanged() {
        if (!isNil(this.clientContext)) {
          this._beanManager = this.clientContext.beanManager
          this._beanManager.onBeanUpdate(this._onBeanPropertyChanged.bind(this))
          this._beanManager.onArrayUpdate(this._onBeanPropertySpliced.bind(this))
        }
      }

      /**
       * Notifies the Dolphin server about bean property value changes.
       *
       * @param {Object} bean the bean with the changed property
       * @param {string} propertyName the property name of the changed value
       * @param {Object} newValue the new value
       * @return {Object} the old value
       */
      _notifyBeanPropertyChanged(bean, propertyName, newValue) {
        return this._beanManager.notifyBeanChange(bean, propertyName,
          newValue)
      }

      /**
       * Notifies the Dolphin server about bean property array splices.
       *
       * @param {Object} bean the bean with the spliced array property
       * @param {string} propertyName the property name of the spliced array
       * @param {number} startIndex the start index of the splice
       * @param {Object} removedItems the removed array items
       * @param {number} addedCount the count of added items
       */
      _notifyBeanPropertySpliced(bean, propertyName, startIndex, removedItems, addedCount) {
        return this._beanManager.notifyArrayChange(bean, propertyName,
          startIndex, addedCount, removedItems)
      }

      /**
       * Receives changes of the `model` property and its subproperties.
       */
      _onModelChanged(changeRecord) {
        console.log("changeRecord:", JSON.stringify(changeRecord, null, " "))

        // subproperty change record:
        // path. Path to the property that changed. Use this to determine whether a property changed, a sub-property changed, or an array was mutated.
        // value. New value of the path that changed.
        // base. The object matching the non-wildcard portion of the path.

        // * @param {string} path Path that should be notified.
        // * @param {Array} splices Array of splice records indicating ordered
        // *   changes that occurred to the array. Each record should have the
        // *   following fields:
        // *    * index: index at which the change occurred
        // *    * removed: array of items that were removed from this index
        // *    * addedCount: number of new items added at this index
        // *    * object: a reference to the array in question
        // *    * type: the string literal 'splice'

        // Change record for array splices.
        if (changeRecord.path.endsWith(".splices") && hasArraySpliceRecords(changeRecord)) {
          // model.<modelPropertyPath>.splices
          const model = changeRecord.base
          const propertyPath = this._slicePropertyPath(changeRecord.path, 1, -1)

          const spliceRecords = changeRecord.value.indexSplices
          for (const spliceRecord of spliceRecords) {
            const startIndex = spliceRecord.index
            const removedItems = spliceRecord.removed
            const addedCount = spliceRecord.addedCount

            this._notifyBeanPropertySpliced(model, propertyPath,
              startIndex, removedItems, addedCount)
            this._binderUpdateArray(changeRecord, spliceRecord)
          }
        }
        // Change record for subproperty updates.
        else {
          // model.<modelPropertyPath>.splices
          const model = changeRecord.base
          const propertyPath = this._slicePropertyPath(changeRecord.path, 1)

          const newValue = changeRecord.value
          this._notifyBeanPropertyChanged(model, propertyPath, newValue)

          // check if is length of array.
          // const value = Polymer.Path.get(model, propertyPath)
          // console.log("__", propertyPath, Array.isArray(value))
        }
      }

      /**
       * Receives an initial bean from the Dolphin server.
       */
      _onBeanChanged(bean) {
        // console.log("on bean changed", bean)
        this.set("model", bean)
      }

      /**
       * Receives a bean property change from the Dolphin server.
       */
      _onBeanPropertyChanged(bean, propertyName, newValue, oldValue) {
        // HERE: is this object comparison right?
        if (isEqual(oldValue, newValue)) { return }

        const propertyPaths = this._queryPropertyPaths(bean)
        if (propertyPaths.size > 0) {
          // HERE: is it ok to just fire property changes for the first element?
          const propertyPath = propertyPaths[0]
          this.set(propertyPath, newValue)
        }
        else {
          bean[propertyName] = newValue
        }
      }

      /**
       * Receives a bean property array change from the Dolphin server.
       */
      _onBeanPropertySpliced(bean, propertyName, startIndex, removedCount, addedItems) {
        const items = bean[propertyName]
        const oldItems = items.slice(startIndex, startIndex + removedCount)

        // HERE: is this object comparison right?
        if (isDeepEqual(items, oldItems)) { return }

        const propertyPaths = this._queryPropertyPaths(bean)
        if (propertyPath.size > 0) {
          // HERE: is it ok to just fire property changes for the first element?
          const propertyPath = propertyPaths[0]
          this.splice(propertyPath, startIndex, removedCount, ...addedItems)
        }
        else {
          items.splice(startIndex, removedCount, ...addedItems)
        }
      }

      // apply bean/array changes from dolphin to the model (bean to propertyPath)
      // unregister old and register new property paths after model changed (beans, arrays).
      // register and unregister property paths and subproperty paths of arrays and beans.

      _binderUpdateArray(changeRecord, spliceRecord) {
        const model = changeRecord.base
        const path = this._slicePropertyPath(changeRecord.path, 1, -1)
        const items = Polymer.Path.get(model, path)
        console.log("u", path, items)

        // Starting from the start index specified, removes 0 or more items
        // from the array and inserts 0 or more new items in their place.
        const startIndex = spliceRecord.index
        const removedItems = spliceRecord.removed
        const addedCount = spliceRecord.addedCount
        console.log("splices", JSON.stringify({ startIndex, removedItems, addedCount }, null, " "))

        for (let removedIndex = 0; removedIndex < removedItems.length; removedIndex++) {
          const removedItem = removedItems[removedIndex]
          const propertyPath = "model." + path + "." + (startIndex + removedIndex)
          this._binderUnbind(removedItem, propertyPath)
        }

        for (let addedIndex = startIndex + addedCount; addedIndex < items.length; addedIndex++) {
          const addedItem = items[addedIndex]
          const propertyPath = "model." + path + "." + (addedIndex - addedCount + removedItems.length)
          this._binderUnbind(addedItem, propertyPath)
        }

        for (let itemIndex = startIndex; itemIndex < items.length; itemIndex++) {
          const item = items[itemIndex]
          const propertyPath = "model." + path + "." + itemIndex
          this._binderBind(item, propertyPath)
        }
      }

      _binderBind(bean, propertyPath) {
        console.log("bind", JSON.stringify({ bean, propertyPath }, null, " "))

        if (isNil(bean) || !isObject(bean)) { return }
        this._registerPropertyPath(bean, propertyPath)

        forEach(bean, (subBean, propertyName) => {
          const subPropertyPath = propertyPath + "." + propertyName
          this._binderBind(subBean, subPropertyPath)
        })
      }

      _binderUnbind(bean, propertyPath) {
        console.log("unbind", JSON.stringify({ bean, propertyPath }, null, " "))

        if (isNil(bean) || !isObject(bean)) { return }
        this._unregisterPropertyPath(bean, propertyPath)

        forEach(bean, (subBean, propertyName) => {
          const subPropertyPath = propertyPath + "." + propertyName
          this._binderUnbind(subBean, subPropertyPath)
        })
      }

      _queryPropertyPaths(bean) {
        return this._beanRegistry.get(bean) || new Set()
      }

      _registerPropertyPath(bean, propertyPath) {
        const propertyPaths = this._queryPropertyPaths(bean)
        if (propertyPaths.size === 0) {
          this._beanRegistry.set(bean, propertyPaths)
        }
        propertyPaths.add(propertyPath)
      }

      _unregisterPropertyPath(bean, propertyPath) {
        const propertyPaths = this._queryPropertyPaths(bean)
        propertyPaths.delete(propertyPath)
        if (propertyPaths.size === 0) {
          this._beanRegistry.delete(bean)
        }
      }

      _slicePropertyPath(propertyPath, start, end = undefined) {
        const propertyPathArray = Polymer.Path.split(propertyPath)
        return Polymer.Path.normalize(propertyPathArray.slice(start, end))
      }
    }

    window.customElements.define(DolphinController.is, DolphinController)

    function isObject(value) {
      return typeof value === "object"
    }

    function isArray(value) {
      return Array.isArray(value)
    }

    function isNil(value) {
      return value === null || value === undefined
    }

    function isTruthy(value) {
      return !!value
    }

    function isEqual(a, b) {
      return a === b
    }

    function isDeepEqual(a, b) {
      return a === b
    }

    function hasArraySpliceRecords(changeRecord) {
      const { path, value, base } = changeRecord
      return value && value.indexSplices
    }

    function forEach(collection, callback) {
      if (isArray(collection)) {
        for (let itemIndex = 0; itemIndex < bean.length; itemIndex++) {
          callback(collection[itemIndex], itemIndex, collection)
        }
        return collection
      }
      for (let propertyName in Object(collection)) {
        if (collection.hasOwnProperty(propertyName)) {
          callback(collection[propertyName], propertyName, collection)
        }
      }
      return collection
    }

  </script>

</dom-module>