<!--
@license
Copyright 2017 Canoo Engineering AG.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="./bower_components/polymer/polymer-element.html">

<dom-module id="dolphin-controller">

  <script>
    const STATUS_NOT_READY = "NOT-READY"
    const STATUS_READY = "READY"

    /**
     * The `dolphin-controller` element serves as a Dolphin controller.
     *
     * ~~~html
     * <dolphin-controller
     *   auto
     *   name="MovieController"
     *   model="{{hostModel}}"></dolphin-controller>
     * ~~~
     *
     * With `auto` set to `true`, the element automatically creates and destroys a
     * Dolphin controller, when it is attached or detached from the DOM tree.
     *
     * @customElement
     * @polymer
     */
    class DolphinController extends Polymer.Element {
      static get is() {
        return "dolphin-controller"
      }

      static get properties() {
        return {
          /**
           * The `ClientContext` of the Dolphin JavaScript client, which should be already
           * connected. Defaults to `window.clientContext`.
           */
          clientContext: {
            type: Object,
            value: () => window.clientContext
          },

          /**
           * If true, automatically creates and destroys a Dolphin controller, when the
           * element is attached or detached from the DOM tree.
           */
          auto: {
            type: Boolean,
            value: false
          },

          /**
           * The status of the controller. Either "READY" or "NOT-READY".
           */
          status: {
            type: String,
            value: STATUS_NOT_READY
          },

          /**
           * The name of the Dolphin controller.
           */
          name: String,

          /**
           * The model object graph. Receives changes from Dolphin and notifies Dolphin
           * when was changed.
           */
          model: Object
        }
      }

      static get observers() {
        return [
          "_onClientContextChanged(clientContext)",
          "_onModelChanged(model.*)"
        ]
      }

      constructor() {
        super()
        this._beanRegistry = new Map()
      }

      connectedCallback() {
        super.connectedCallback()
        if (isTruthy(this.auto)) {
          this.create()
        }
      }

      disconnectedCallback() {
        super.disconnectedCallback()
        if (isTruthy(this.auto)) {
          this.destroy()
        }
      }

      create() {
        if (!isNil(this.clientContext) && !isNil(this.name)) {
          this._onControllerInitializing()
          this.clientContext.createController(this.name)
            .then(controller => {
              this._onControllerReady(controller)
              if (!isNil(controller.onDestroyed)) {
                controller.onDestroyed(() => {
                  this._onControllerDestroyed(controller)
                })
              }
            })
        }
      }

      destroy() {
        if (!isNil(this._controller)) {
          this._controller.destroy()
        }
      }

      _onClientContextChanged() {
        if (!isNil(this.clientContext)) {
          this._beanManager = this.clientContext.beanManager
          this._beanManager.onBeanUpdate(this._onBeanPropertyChanged.bind(this))
          this._beanManager.onArrayUpdate(this._onBeanPropertyArrayChanged.bind(this))
        }
      }

      _onBeanPropertyChanged(bean, propertyName, newValue) {
        return this._beanManager.notifyBeanChange(bean, propertyName, newValue)
      }

      _onBeanPropertyArrayChanged(bean, propertyName, startIndex, removedCount, addedItems) {
        return this._beanManager.notifyArrayChange(bean, propertyName, startIndex, addedCount, removedItems)
      }

      _onControllerInitializing() {
        // console.log("_onControllerInitializing()", this.name)
        this._controller = null
        this.status = STATUS_NOT_READY
      }

      _onControllerReady(controller) {
        // console.log("_onControllerReady()", this.name, controller)
        this._controller = controller
        this._onBeanChanged(this._controller.model)
        this.status = STATUS_READY
      }

      _onControllerDestroyed(controller) {
        // console.log("_onControllerDestroyed()", this.name, controller)
        this._controller = null
        this.status = STATUS_NOT_READY
      }

      // apply bean/array changes from dolphin to the model (bean to propertyPath)
      // unregister old and register new property paths after model changed (beans, arrays).
      // register and unregister property paths and subproperty paths of arrays and beans.

      _binderUpdateArray(changeRecord, spliceRecord) {
        const model = changeRecord.base
        const path = this._slicePropertyPath(changeRecord.path, 1, -1)
        const items = Polymer.Path.get(model, path)
        console.log("u", path, items)

        // Starting from the start index specified, removes 0 or more items
        // from the array and inserts 0 or more new items in their place.
        const startIndex = spliceRecord.index
        const removedItems = spliceRecord.removed
        const addedCount = spliceRecord.addedCount
        console.log("splices", JSON.stringify({ startIndex, removedItems, addedCount }, null, " "))

        for (let removedIndex = 0; removedIndex < removedItems.length; removedIndex++) {
          const removedItem = removedItems[removedIndex]
          const propertyPath = "model." + path + "." + (startIndex + removedIndex)
          this._binderUnbind(removedItem, propertyPath)
        }

        for (let addedIndex = startIndex + addedCount; addedIndex < items.length; addedIndex++) {
          const addedItem = items[addedIndex]
          const propertyPath = "model." + path + "." + (addedIndex - addedCount + removedItems.length)
          this._binderUnbind(addedItem, propertyPath)
        }

        for (let itemIndex = startIndex; itemIndex < items.length; itemIndex++) {
          const item = items[itemIndex]
          const propertyPath = "model." + path + "." + itemIndex
          this._binderBind(item, propertyPath)
        }
      }

      _binderBind(bean, propertyPath) {
        console.log("bind", JSON.stringify({ bean, propertyPath }, null, " "))

        if (isNil(bean) || !isObject(bean)) { return }
        this._registerPropertyPath(bean, propertyPath)

        forEach(bean, (subBean, propertyName) => {
          const subPropertyPath = propertyPath + "." + propertyName
          this._binderBind(subBean, subPropertyPath)
        })
      }

      _binderUnbind(bean, propertyPath) {
        console.log("unbind", JSON.stringify({ bean, propertyPath }, null, " "))

        if (isNil(bean) || !isObject(bean)) { return }
        this._unregisterPropertyPath(bean, propertyPath)

        forEach(bean, (subBean, propertyName) => {
          const subPropertyPath = propertyPath + "." + propertyName
          this._binderUnbind(subBean, subPropertyPath)
        })
      }

      /**
       * Receives changes of the `model` property and its subproperties.
       */
      _onModelChanged(changeRecord) {
        console.log("changeRecord:", JSON.stringify(changeRecord, null, " "))

        // subproperty change record:
        // path. Path to the property that changed. Use this to determine whether a property changed, a sub-property changed, or an array was mutated.
        // value. New value of the path that changed.
        // base. The object matching the non-wildcard portion of the path.

        // * @param {string} path Path that should be notified.
        // * @param {Array} splices Array of splice records indicating ordered
        // *   changes that occurred to the array. Each record should have the
        // *   following fields:
        // *    * index: index at which the change occurred
        // *    * removed: array of items that were removed from this index
        // *    * addedCount: number of new items added at this index
        // *    * object: a reference to the array in question
        // *    * type: the string literal 'splice'

        // Change record for array splices.
        if (changeRecord.path.endsWith(".splices") && hasArraySpliceRecords(changeRecord)) {
          // model.<modelPropertyPath>.splices
          const model = changeRecord.base
          const propertyPath = this._slicePropertyPath(changeRecord.path, 1, -1)

          const spliceRecords = changeRecord.value.indexSplices
          for (const spliceRecord of spliceRecords) {
            const startIndex = spliceRecord.index
            const removedItems = spliceRecord.removed
            const addedCount = spliceRecord.addedCount

            this._notifyBeanArrayChanged(model, propertyPath,
              startIndex, addedCount, removedItems)
            this._binderUpdateArray(changeRecord, spliceRecord)
          }
        }
        // Change record for subproperty updates.
        else {
          // model.<modelPropertyPath>.splices
          const model = changeRecord.base
          const propertyPath = this._slicePropertyPath(changeRecord.path, 1)

          const newValue = changeRecord.value
          this._notifyBeanChanged(model, propertyPath, newValue)

          // check if is length of array.
          // const value = Polymer.Path.get(model, propertyPath)
          // console.log("__", propertyPath, Array.isArray(value))
        }
      }

      /**
       * Notifies the Dolphin server about bean changes.
       */
      _notifyBeanChanged(model, propertyPath, newValue) {
        // console.log("notify bean changed:", model, propertyPath, newValue)
        const bean = Polymer.Path.get(model, propertyPath)
        const propertyName = this._slicePropertyPath(propertyPath, -1)
        // console.log("-->", propertyName, bean)
      }

      /**
       * Notifies the Dolphin server about bean array changes.
       */
      _notifyBeanArrayChanged(model, propertyPath, startIndex, addedCount, removedItems) {
        // console.log("notify bean array changed:", model, propertyPath, startIndex, addedCount, removedItems)
      }

      /**
       * Receives an initial bean from the Dolphin server.
       */
      _onBeanChanged(bean) {
        // console.log("on bean changed", bean)
        this.set("model", bean)
      }

      /**
       * Receives a bean property change from the Dolphin server.
       */
      _onBeanPropertyChanged(bean, propertyName, newValue, oldValue) {
        // console.log("on bean property changed:",
        //   bean, propertyName, newValue, oldValue)

        // HERE: is this object comparison right?
        if (isEqual(oldValue, newValue)) { return }

        const propertyPaths = this._queryPropertyPaths(bean)
        if (propertyPaths.size > 0) {
          // HERE: is it ok to just fire property changes for the first element?
          const propertyPath = propertyPaths[0]
          this.set(propertyPath, newValue)
        }
        else {
          bean[propertyName] = newValue
        }
      }

      /**
       * Receives a bean property array change from the Dolphin server.
       */
      _onBeanPropertyArrayChanged(bean, propertyName, startIndex, removedCount, addedItems) {
        // console.log("on bean property array changed:",
        //   bean, propertyName, startIndex, removedCount, addedItems)

        const items = bean[propertyName]
        const oldItems = items.slice(startIndex, startIndex + removedCount)

        // HERE: is this object comparison right?
        if (isDeepEqual(items, oldItems)) { return }

        const propertyPaths = this._queryPropertyPaths(bean)
        if (propertyPath.size > 0) {
          // HERE: is it ok to just fire property changes for the first element?
          const propertyPath = propertyPaths[0]
          this.splice(propertyPath, startIndex, removedCount, ...addedItems)
        }
        else {
          items.splice(startIndex, removedCount, ...addedItems)
        }
      }

      _queryPropertyPaths(bean) {
        return this._beanRegistry.get(bean) || new Set()
      }

      _registerPropertyPath(bean, propertyPath) {
        const propertyPaths = this._queryPropertyPaths(bean)
        if (propertyPaths.size === 0) {
          this._beanRegistry.set(bean, propertyPaths)
        }
        propertyPaths.add(propertyPath)
      }

      _unregisterPropertyPath(bean, propertyPath) {
        const propertyPaths = this._queryPropertyPaths(bean)
        propertyPaths.delete(propertyPath)
        if (propertyPaths.size === 0) {
          this._beanRegistry.delete(bean)
        }
      }

      _slicePropertyPath(propertyPath, start, end = undefined) {
        const propertyPathArray = Polymer.Path.split(propertyPath)
        return Polymer.Path.normalize(propertyPathArray.slice(start, end))
      }
    }

    window.customElements.define(DolphinController.is, DolphinController)

    function isObject(value) {
      return typeof value === "object"
    }

    function isNil(value) {
      return value === null || value === undefined
    }

    function isTruthy(value) {
      return !!value
    }

    function isEqual(a, b) {
      return a === b
    }

    function isDeepEqual(a, b) {
      return a === b
    }

    function hasArraySpliceRecords(changeRecord) {
      const { path, value, base } = changeRecord
      return value && value.indexSplices
    }

    function forEach(collection, callback) {
      if (Array.isArray(collection)) {
        for (let itemIndex = 0; itemIndex < bean.length; itemIndex++) {
          callback(collection[itemIndex], itemIndex, collection)
        }
        return collection
      }
      for (let propertyName in Object(collection)) {
        if (collection.hasOwnProperty(propertyName)) {
          callback(collection[propertyName], propertyName, collection)
        }
      }
      return collection
    }

  </script>

</dom-module>