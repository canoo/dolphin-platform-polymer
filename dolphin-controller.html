<!--
@license
Copyright 2017 Canoo Engineering AG.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="./bower_components/polymer/polymer-element.html">

<dom-module id="dolphin-controller">

  <script>
    const STATUS_NOT_READY = "NOT-READY"
    const STATUS_READY = "READY"

    /**
     * The `dolphin-controller` element serves as a Dolphin controller.
     *
     * ~~~html
     * <dolphin-controller
     *   name="MovieController"
     *   model="{{movies}}"></dolphin-controller>
     * ~~~
     *
     * With `noauto` set to `true`, the element not automatically creates and destroys
     * a Dolphin controller, when it is attached or detached from the DOM tree.
     *
     * @customElement
     * @polymer
     */
    class DolphinController extends Polymer.Element {
      static get is() {
        return "dolphin-controller"
      }

      static get properties() {
        return {
          /**
           * The `ClientContext` of the Dolphin JavaScript client, which should be already
           * connected. Defaults to `window.clientContext`.
           */
          clientContext: {
            type: Object,
            value: () => window.clientContext
          },

          /**
           * If false, automatically creates and destroys a Dolphin controller, when the
           * element is attached or detached from the DOM tree.
           */
          noauto: {
            type: Boolean,
            value: false
          },

          /**
           * The status of the Dolphin controller. Either "READY" or "NOT-READY". Initially
           * is set to "NOT-READY".
           */
          status: {
            type: String,
            value: STATUS_NOT_READY
          },

          /**
           * The name of the Dolphin controller.
           */
          name: String,

          /**
           * The model object graph. Receives changes from Dolphin and notifies Dolphin
           * when was changed.
           *
           * @type {Object}
           */
          model: Object
        }
      }

      static get observers() {
        return [
          "_onClientContextChanged(clientContext)",
          "_onModelChanged(model.*)"
        ]
      }

      constructor() {
        super()
        this._beanRegistry = new Map()
      }

      connectedCallback() {
        super.connectedCallback()
        if (!isTruthy(this.noauto)) {
          this.create()
        }
      }

      disconnectedCallback() {
        super.disconnectedCallback()
        if (!isTruthy(this.noauto)) {
          this.destroy()
        }
      }

      /**
       * Creates a Dolphin controller.
       */
      create() {
        if (!isNil(this.clientContext) && !isNil(this.name)) {
          this._onControllerInitializing()
          this.clientContext.createController(this.name)
            .then(controller => {
              this._onControllerReady(controller)
              if (!isNil(controller.onDestroyed)) {
                controller.onDestroyed(() => {
                  this._onControllerDestroyed(controller)
                })
              }
            })
        }
      }

      /**
       * Destroys a Dolphin controller.
       */
      destroy() {
        if (!isNil(this._controller)) {
          this._controller.destroy()
        }
      }

      /**
       * Invokes a Dolphin action.
       *
       * @param {string} name Name of the action
       * @param {any[]} params Array of params for the action
       */
      invoke(name, params) {
        this._controller.invoke(name, params)
      }

      /**
       * Called when the controller is initializing.
       */
      _onControllerInitializing() {
        this._controller = null
        this.status = STATUS_NOT_READY
      }

      /**
       * Called when the controller is ready.
       *
       * @param {any} controller The controller
       */
      _onControllerReady(controller) {
        this._controller = controller
        this.status = STATUS_READY
        this._onRootBeanChanged(this._controller.model)
      }

      /**
       * Called when the controller is destroyed.
       *
       * @param {any} controller The controller
       */
      _onControllerDestroyed(controller) {
        this._controller = null
        this.status = STATUS_NOT_READY
      }

      /**
       *
       */
      _onClientContextChanged() {
        if (!isNil(this.clientContext)) {
          this._beanManager = this.clientContext.beanManager
          this._beanManager.onBeanUpdate(this._onBeanPropertyChanged.bind(this))
          this._beanManager.onArrayUpdate(this._onBeanPropertySpliced.bind(this))
        }
      }

      /**
       * Notifies the Dolphin server about bean property value changes.
       *
       * @param {object} bean Bean with the changed property
       * @param {string} propertyName Property name of the changed value
       * @param {any} newValue New value
       * @return {any} Old value
       */
      _notifyBeanPropertyChanged(bean, propertyName, newValue) {
        return this._beanManager.notifyBeanChange(bean, propertyName,
          newValue)
      }

      /**
       * Notifies the Dolphin server about bean property array splices.
       *
       * @param {object} bean Bean with the spliced array property
       * @param {string} propertyName Property name of the spliced array
       * @param {number} startIndex Index at which the change occurred
       * @param {any[]} removedItems Array of items that were removed from this index
       * @param {number} addedCount Number of items that were added at this index
       */
      _notifyBeanPropertySpliced(bean, propertyName, startIndex, removedItems, addedCount) {
        return this._beanManager.notifyArrayChange(bean, propertyName,
          startIndex, addedCount, removedItems)
      }

      /**
       * Receives changes of the `model` property and its subproperties.
       *
       * @param {any} changeRecord Record with change information
       */
      _onModelChanged(changeRecord) {
        if (this.status !== STATUS_READY) { return }
        // console.log("--", pretty(changeRecord))

        function hasArraySpliceRecords(changeRecord) {
          const { path, value, base } = changeRecord
          return value && value.indexSplices
        }

        // Change record for array splices.
        if (changeRecord.path.endsWith(".splices") && hasArraySpliceRecords(changeRecord)) {
          // model.<propertyPath>.splices
          const rootProperty = changeRecord.base
          const propertyPath = this._slicePropertyPath(changeRecord.path, 1, -1)

          const parentPropertyPath = this._slicePropertyPath(propertyPath, 0, -1)
          const propertyName = this._slicePropertyPath(propertyPath, -1)
          const bean = Polymer.Path.get(rootProperty, parentPropertyPath)
          const property = Polymer.Path.get(rootProperty, propertyPath)

          const spliceRecords = changeRecord.value.indexSplices
          for (const spliceRecord of spliceRecords) {
            const items = spliceRecord.object
            const startIndex = spliceRecord.index
            const removedItems = spliceRecord.removed
            const addedCount = spliceRecord.addedCount

            this._notifyBeanPropertySpliced(bean, propertyName,
              startIndex, removedItems, addedCount)
            this._binderUpdateArray(items, propertyPath,
              startIndex, removedItems, addedCount)
          }
        }
        // Change record for subproperty updates.
        else {
          const rootProperty = { model: changeRecord.base }
          const propertyPath = changeRecord.path

          // model.<propertyPath>
          const parentPropertyPath = this._slicePropertyPath(propertyPath, 0, -1)
          const propertyName = this._slicePropertyPath(propertyPath, -1)
          const bean = Polymer.Path.get(rootProperty, parentPropertyPath)
          const property = Polymer.Path.get(rootProperty, propertyPath)

          const newValue = changeRecord.value
          const oldValue = this._notifyBeanPropertyChanged(bean, propertyName, newValue)

          if (!isNil(oldValue)) {
            this._binderUnbind(oldValue, propertyPath)
          }
          if (!isNil(newValue)) {
            this._binderBind(newValue, propertyPath)
          }
        }

        // console.log("_beanRegistry", pretty(this._beanRegistry))
      }

      /**
       * Receives an initial bean from the Dolphin server.
       *
       * @param {object} bean Initial bean at the root
       */
      _onRootBeanChanged(bean) {
        this.set("model", bean)
      }

      /**
       * Receives a bean property change from the Dolphin server.
       *
       * @param {object} bean Bean with the changed property
       * @param {string} propertyName Property name of the changed value
       * @param {any} newValue New value
       * @param {any} oldValue Old value
       */
      _onBeanPropertyChanged(bean, propertyName, newValue, oldValue) {
        // HERE: is this object comparison right?
        if (isEqual(newValue, oldValue)) { return }

        const propertyPaths = this._queryPropertyPaths(bean)
        if (propertyPaths.size > 0) {
          // HERE: is it ok to fire property changes only for the first element?
          const propertyPath = propertyPaths[0]
          this.set(propertyPath, newValue)
        }
        else {
          bean[propertyName] = newValue
        }
      }

      /**
       * Receives a bean property splice from the Dolphin server.
       *
       * @param {object} bean Bean with the spliced array property
       * @param {string} propertyName Property name of the spliced array
       * @param {number} startIndex Index at which the change occurred
       * @param {number} removedCount Number of items that were removed from this index
       * @param {any[]} addedItems Array of items that were added at this index
       */
      _onBeanPropertySpliced(bean, propertyName, startIndex, removedCount, addedItems) {
        // HERE: is this object comparison right?
        const newItems = bean[propertyName]
        const oldItems = newItems.slice(startIndex, startIndex + removedCount)
        if (isArrayEqual(newItems, oldItems)) { return }

        const propertyPaths = this._queryPropertyPaths(bean)
        if (propertyPath.size > 0) {
          // HERE: is it ok to fire property changes only for the first element?
          const propertyPath = propertyPaths[0]
          this.splice(propertyPath, startIndex, removedCount, ...addedItems)
        }
        else {
          bean[propertyName].splice(startIndex, removedCount, ...addedItems)
        }
      }

      /**
       * @param {any[]} items Array of current items
       * @param {string} propertyPath Property path of the items
       * @param {number} startIndex Index at which the change occurred
       * @param {any[]} removedItems Array of items that were removed from this index
       * @param {number} addedCount Number of items that were added at this index
       */
      _binderUpdateArray(items, propertyPath, startIndex, removedItems, addedCount) {
        for (let removedIndex = 0; removedIndex < removedItems.length; removedIndex++) {
          const removedItem = removedItems[removedIndex]
          const itemPropertyPath = this._buildPropertyPath(propertyPath, startIndex + removedIndex)
          this._binderUnbind(removedItem, itemPropertyPath)
        }

        // HERE: is the name addedIndex appropriate here?
        for (let addedIndex = startIndex + addedCount; addedIndex < items.length; addedIndex++) {
          const addedItem = items[addedIndex]
          const itemPropertyPath = this._buildPropertyPath(propertyPath, addedIndex - addedCount + removedItems.length)
          this._binderUnbind(addedItem, itemPropertyPath)
        }

        for (let itemIndex = startIndex; itemIndex < items.length; itemIndex++) {
          const item = items[itemIndex]
          const itemPropertyPath = this._buildPropertyPath(propertyPath, itemIndex)
          this._binderBind(item, itemPropertyPath)
        }
      }

      /**
       *
       */
      _binderBind(bean, propertyPath) {
        if (isNil(bean) || !isObject(bean)) { return }

        this._registerPropertyPath(bean, propertyPath)

        forEach(bean, (subBean, propertyName) => {
          const subPropertyPath = this._buildPropertyPath(propertyPath, propertyName)
          this._binderBind(subBean, subPropertyPath)
        })
      }

      /**
       *
       */
      _binderUnbind(bean, propertyPath) {
        if (isNil(bean) || !isObject(bean)) { return }

        this._unregisterPropertyPath(bean, propertyPath)

        forEach(bean, (subBean, propertyName) => {
          const subPropertyPath = this._buildPropertyPath(propertyPath, propertyName)
          this._binderUnbind(subBean, subPropertyPath)
        })
      }

      /**
       *
       */
      _queryPropertyPaths(bean) {
        return this._beanRegistry.get(bean) || new Set()
      }

      /**
       *
       */
      _registerPropertyPath(bean, propertyPath) {
        const propertyPaths = this._queryPropertyPaths(bean)
        if (propertyPaths.size === 0) {
          this._beanRegistry.set(bean, propertyPaths)
        }
        propertyPaths.add(propertyPath)
      }

      /**
       *
       */
      _unregisterPropertyPath(bean, propertyPath) {
        const propertyPaths = this._queryPropertyPaths(bean)
        propertyPaths.delete(propertyPath)
        if (propertyPaths.size === 0) {
          this._beanRegistry.delete(bean)
        }
      }

      /**
       *
       */
      _buildPropertyPath(...propertyPathElements) {
        return Polymer.Path.normalize(propertyPathElements.filter(it => it.length > 0))
      }

      /**
       *
       */
      _slicePropertyPath(propertyPath, start, end = undefined) {
        const propertyPathElements = Polymer.Path.split(propertyPath)
        return Polymer.Path.normalize(propertyPathElements.slice(start, end))
      }
    }

    window.customElements.define(DolphinController.is, DolphinController)

    function pretty(value, padding = "  ") {
      function replacer(key, value) {
        if (value.constructor.name === "Map") {
          return Array.from(value)
        }
        if (value.constructor.name === "Set") {
          return Array.from(value)
        }
        return value
      }
      return JSON.stringify(value, replacer, padding)
    }

    /**
     * True, if `value` is an object.
     */
    function isObject(value) {
      return typeof value === "object"
    }

    /**
     * True, if `value` is an array.
     */
    function isArray(value) {
      return Array.isArray(value)
    }

    /**
     * True, if `value` is `null` or `undefined`.
     */
    function isNil(value) {
      return value === null || value === undefined
    }

    /**
     * True, if `value` is truthy.
     */
    function isTruthy(value) {
      return !!value
    }

    function isEqual(a, b) {
      return a === b
      // return Object.is(a, b)
    }

    /**
     * Compares if one array is equal to another array.
     *
     * @param {Array} a One array
     * @param {Array} b Another array
     * @returns {boolean} True, if the array is equal to the other array
     */
    function isArrayEqual(a, b) {
      if ((a === b) || (isNil(a) && isNil(b))) { return true }
      if (isNil(a) !== isNil(b)) { return false }
      if (a.length !== b.length) { return false }

      for (let index = 0; index < a.length; index++) {
        if (a[index] !== b[index]) {
          return false
        }
      }
      return true
    }

    // function forEach(collection, callback) {
    //   Object.keys(collection).forEach(key =>
    //     callback(collection[key], key, collection)
    //   )
    // }

    function forEach(collection, callback) {
      if (isArray(collection)) {
        const array = collection
        for (let itemIndex = 0; itemIndex < array.length; itemIndex++) {
          const item = array[itemIndex]
          callback(item, itemIndex, array)
        }
        return array
      }
      if (isObject(collection)) {
        const object = Object(collection)
        for (let propertyName in object) {
          if (object.hasOwnProperty(propertyName)) {
            const property = object[propertyName]
            callback(property, propertyName, object)
          }
        }
        return object
      }
      return collection
    }

  </script>

</dom-module>